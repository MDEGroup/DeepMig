To migrate the `RedisCache` class from using Log4j2 to SLF4J, you'll need to update the imports and modify how the logger is instantiated. Here are the steps and the updated code:

1. **Change the Logger Import**: Replace the import statement for Log4j2 with the one for SLF4J.
2. **Update Logger Instantiation**: Modify the logger instantiation to use SLF4J's `LoggerFactory`.

Here's the modified version of the class with the necessary changes:

```java
package com.llsfw.core.security.session.redis;

import com.llsfw.core.security.session.SerializeUtils;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.apache.shiro.cache.Cache;
import org.springframework.util.CollectionUtils;

public class RedisCache<K, V> implements Cache<K, V> {
  private static final Logger LOG = LoggerFactory.getLogger(RedisCache.class);
  
  private DbManager cache;
  
  private String keyPrefix;
  
  public RedisCache(DbManager cache, String prefix) {
    this(cache);
    this.keyPrefix = prefix;
  }
  
  public RedisCache(DbManager cache) {
    if (cache == null)
      throw new IllegalArgumentException("Cache argument cannot be null."); 
    this.cache = cache;
  }
  
  private byte[] getByteKey(K key) {
    if (key instanceof String) {
      String preKey = this.keyPrefix + key;
      return preKey.getBytes();
    } 
    return SerializeUtils.serialize(key);
  }
  
  public V get(K key) {
    LOG.debug("[cache] key [{}]", key);
    if (key == null)
      return null; 
    byte[] rawValue = this.cache.get(getByteKey(key));
    return (V) SerializeUtils.deserialize(rawValue);
  }
  
  public V put(K key, V value) {
    LOG.debug("[cache] put key [{}]", key);
    this.cache.set(getByteKey(key), SerializeUtils.serialize(value));
    return value;
  }
  
  public V remove(K key) {
    LOG.debug("[cache] remove key [{}]", key);
    V previous = get(key);
    this.cache.del(getByteKey(key));
    return previous;
  }
  
  public void clear() {
    LOG.debug("[cache] clear");
    this.cache.flushDB();
  }
  
  public int size() {
    Long longSize = this.cache.dbSize();
    return longSize.intValue();
  }
  
  public Set<K> keys() {
    LOG.debug("[cache] keys");
    Set<byte[]> keys = this.cache.keys(this.keyPrefix + "*");
    if (CollectionUtils.isEmpty(keys))
      return Collections.emptySet(); 
    Set<K> newKeys = new HashSet<>();
    for (byte[] key : keys)
      newKeys.add((K)SerializeUtils.deserialize(key)); 
    return newKeys;
  }
  
  public Collection<V> values() {
    LOG.debug("[cache] values");
    Set<byte[]> keys = this.cache.keys(this.keyPrefix + "*");
    if (!CollectionUtils.isEmpty(keys)) {
      List<V> values = new ArrayList<>(keys.size());
      for (byte[] key : keys) {
        V value = get((K)SerializeUtils.deserialize(key));
        if (value != null)
          values.add(value); 
      } 
      return Collections.unmodifiableList(values);
    } 
    return Collections.emptyList();
  }
}
```

This updated code uses SLF4J for logging, which will provide a more flexible approach to logging across various logging frameworks and better integration with modern Java environments.