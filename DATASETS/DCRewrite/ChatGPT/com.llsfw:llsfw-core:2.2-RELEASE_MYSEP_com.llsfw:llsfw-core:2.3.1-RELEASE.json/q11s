You are a Java code assistant. Given this Java class: 

package com.llsfw.core.pagequery;

import com.llsfw.core.datasource.DynamicDataSource;
import com.llsfw.core.exception.SystemException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Arrays;
import java.util.List;
import java.util.Properties;
import javax.sql.DataSource;
import org.apache.ibatis.executor.ErrorContext;
import org.apache.ibatis.executor.Executor;
import org.apache.ibatis.executor.ExecutorException;
import org.apache.ibatis.mapping.BoundSql;
import org.apache.ibatis.mapping.MappedStatement;
import org.apache.ibatis.mapping.ParameterMapping;
import org.apache.ibatis.mapping.ParameterMode;
import org.apache.ibatis.mapping.SqlSource;
import org.apache.ibatis.plugin.Interceptor;
import org.apache.ibatis.plugin.Intercepts;
import org.apache.ibatis.plugin.Invocation;
import org.apache.ibatis.plugin.Plugin;
import org.apache.ibatis.plugin.Signature;
import org.apache.ibatis.reflection.MetaObject;
import org.apache.ibatis.reflection.property.PropertyTokenizer;
import org.apache.ibatis.session.Configuration;
import org.apache.ibatis.session.ResultHandler;
import org.apache.ibatis.session.RowBounds;
import org.apache.ibatis.type.TypeHandler;
import org.apache.ibatis.type.TypeHandlerRegistry;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

@Intercepts({@Signature(type = Executor.class, method = "query", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class})})
public class PageInterceptor implements Interceptor {
  private static final ThreadLocal<PageResult> LOCAL_PAGE = new ThreadLocal<>();
  
  private static final Logger LOG = LogManager.getLogger();
  
  private String dialect;
  
  private String pageSqlId;
  
  public String getDialect() {
    return this.dialect;
  }
  
  public void setDialect(String dialect) {
    this.dialect = dialect;
  }
  
  public String getPageSqlId() {
    return this.pageSqlId;
  }
  
  public void setPageSqlId(String pageSqlId) {
    this.pageSqlId = pageSqlId;
  }
  
  private static PageResult getLocalPage() {
    return LOCAL_PAGE.get();
  }
  
  private static void setLocalPage(PageResult page) {
    LOCAL_PAGE.set(page);
  }
  
  private static void clearLocalPage() {
    LOCAL_PAGE.remove();
  }
  
  public static void startPage(int pageSize, int curPage) throws SystemException {
    if (pageSize <= 0)
      throw new SystemException("pageSize <= 0"); 
    if (curPage <= 0)
      throw new SystemException("curpage <= 0"); 
    PageResult page = new PageResult();
    page.setPageSize(pageSize);
    page.setCurPage(curPage);
    setLocalPage(page);
  }
  
  public static void startPage(int pageSize, int curPage, int totalRecords) throws SystemException {
    if (totalRecords < 0)
      throw new SystemException("totalRecords < 0"); 
    startPage(pageSize, curPage);
    PageResult page = getLocalPage();
    page.setTotalRecords(totalRecords);
    setLocalPage(page);
  }
  
  public static <E> PageResult<E> getPageResult(List<E> result) {
    return (PageResult<E>)result;
  }
  
  public Object intercept(Invocation invocation) throws Throwable {
    try {
      PageResult pr = getLocalPage();
      MappedStatement mappedStatement = (MappedStatement)invocation.getArgs()[0];
      String id = mappedStatement.getId();
      LOG.debug("MappedStatement id = " + id);
      if (id.matches(this.pageSqlId) && pr != null) {
        Object parameter = invocation.getArgs()[1];
        BoundSql boundSql = mappedStatement.getBoundSql(parameter);
        String sql = boundSql.getSql();
        Connection connection = getConnection(mappedStatement);
        if (!pr.isHasTotalRecords()) {
          int count = countRecords(connection, sql, mappedStatement, boundSql);
          pr.setTotalRecords(count);
        } 
        if (pr.getTotalRecords() > 0) {
          int totalPages = pr.getTotalRecords() / pr.getPageSize() + ((pr.getTotalRecords() % pr.getPageSize() > 0) ? 1 : 0);
          pr.setTotalPages(totalPages);
          if (pr.getCurPage() > pr.getTotalPages())
            pr.setCurPage(pr.getTotalPages()); 
        } else {
          pr.setCurPage(1);
          pr.setTotalPages(0);
        } 
        String pageSql = generatePageSql(sql, pr);
        invocation.getArgs()[2] = RowBounds.DEFAULT;
        MappedStatement newMappedStatement = copyFromNewSql(mappedStatement, boundSql, pageSql, boundSql.getParameterMappings(), boundSql.getParameterObject());
        invocation.getArgs()[0] = newMappedStatement;
        if (pr.getTotalRecords() > 0) {
          Object result = invocation.proceed();
          pr.addAll((List)result);
        } 
        return pr;
      } 
      return invocation.proceed();
    } finally {
      clearLocalPage();
    } 
  }
  
  private static MappedStatement copyFromMappedStatement(MappedStatement ms, SqlSource newSqlSource) {
    MappedStatement.Builder builder = new MappedStatement.Builder(ms.getConfiguration(), ms.getId(), newSqlSource, ms.getSqlCommandType());
    builder.resource(ms.getResource());
    builder.fetchSize(ms.getFetchSize());
    builder.statementType(ms.getStatementType());
    builder.keyGenerator(ms.getKeyGenerator());
    String[] keys = ms.getKeyProperties();
    if (keys != null) {
      String keysstr = Arrays.toString((Object[])keys);
      keysstr = keysstr.replace("[", "");
      keysstr = keysstr.replace("]", "");
      builder.keyProperty(keysstr);
    } 
    builder.timeout(ms.getTimeout());
    builder.parameterMap(ms.getParameterMap());
    builder.resultMaps(ms.getResultMaps());
    builder.cache(ms.getCache());
    builder.databaseId(ms.getDatabaseId());
    builder.flushCacheRequired(ms.isFlushCacheRequired());
    String[] keyColumns = ms.getKeyColumns();
    if (keyColumns != null) {
      String keysstr = Arrays.toString((Object[])keyColumns);
      keysstr = keysstr.replace("[", "");
      keysstr = keysstr.replace("]", "");
      builder.keyColumn(keysstr);
    } 
    builder.lang(ms.getLang());
    String[] resulSets = ms.getResulSets();
    if (resulSets != null) {
      String keysstr = Arrays.toString((Object[])resulSets);
      keysstr = keysstr.replace("[", "");
      keysstr = keysstr.replace("]", "");
      builder.resulSets(keysstr);
    } 
    builder.resultSetType(ms.getResultSetType());
    builder.statementType(ms.getStatementType());
    builder.useCache(ms.isUseCache());
    return builder.build();
  }
  
  private static MappedStatement copyFromNewSql(MappedStatement mappedStatement, BoundSql boundSql, String sql, List<ParameterMapping> parameterMappings, Object parameter) {
    BoundSql newBoundSql = copyFromBoundSql(mappedStatement, boundSql, sql, parameterMappings, parameter);
    return copyFromMappedStatement(mappedStatement, new BoundSqlSqlSource(newBoundSql));
  }
  
  private static BoundSql copyFromBoundSql(MappedStatement mappedStatement, BoundSql boundSql, String sql, List<ParameterMapping> parameterMappings, Object parameter) {
    BoundSql newBoundSql = new BoundSql(mappedStatement.getConfiguration(), sql, parameterMappings, parameter);
    for (ParameterMapping mapping : boundSql.getParameterMappings()) {
      String prop = mapping.getProperty();
      if (boundSql.hasAdditionalParameter(prop))
        newBoundSql.setAdditionalParameter(prop, boundSql.getAdditionalParameter(prop)); 
    } 
    return newBoundSql;
  }
  
  private static Connection getConnection(MappedStatement mappedStatement) throws SQLException {
    DataSource dataSource = DynamicDataSource.getCurrentDataSource();
    if (dataSource == null)
      dataSource = mappedStatement.getConfiguration().getEnvironment().getDataSource(); 
    return dataSource.getConnection();
  }
  
  private String generatePageSql(String sql, PageResult pr) {
    if (pr != null && (this.dialect != null || !"".equals(this.dialect))) {
      StringBuilder pageSql = new StringBuilder();
      if ("mysql".equals(this.dialect)) {
        pageSql.append(sql);
        pageSql.append(" LIMIT " + ((pr.getCurPage() - 1) * pr.getPageSize()) + "," + pr.getPageSize());
      } else if ("oracle".equals(this.dialect)) {
        pageSql.append(" SELECT * FROM (SELECT TMP_TB.*,ROWNUM ROW_ID FROM ( ");
        pageSql.append(sql);
        pageSql.append(" )  TMP_TB WHERE ROWNUM <= ");
        pageSql.append(pr.getPageSize() + (pr.getCurPage() - 1) * pr.getPageSize());
        pageSql.append(" ) WHERE ROW_ID >= ");
        pageSql.append(1 + (pr.getCurPage() - 1) * pr.getPageSize());
      } 
      return pageSql.toString();
    } 
    return sql;
  }
  
  private int countRecords(Connection connection, String originalSql, MappedStatement mappedStatement, BoundSql boundSql) throws SQLException {
    PreparedStatement countStmt = null;
    ResultSet rs = null;
    try {
      int totalRecorld = 0;
      Object paramObject = boundSql.getParameterObject();
      StringBuilder countSql = new StringBuilder(originalSql.length() + 100);
      countSql.append(" select count(1) from ( ").append(originalSql).append(" ) C ");
      countStmt = connection.prepareStatement(countSql.toString());
      BoundSql countBS = new BoundSql(mappedStatement.getConfiguration(), originalSql, boundSql.getParameterMappings(), paramObject);
      setParameters(countStmt, mappedStatement, countBS, paramObject);
      rs = countStmt.executeQuery();
      if (rs.next())
        totalRecorld = rs.getInt(1); 
      return totalRecorld;
    } finally {
      if (rs != null)
        rs.close(); 
      if (countStmt != null)
        countStmt.close(); 
    } 
  }
  
  private void setParameters(PreparedStatement ps, MappedStatement mappedStatement, BoundSql boundSql, Object parameterObject) throws SQLException {
    ErrorContext.instance().activity("setting parameters").object(mappedStatement.getParameterMap().getId());
    List<ParameterMapping> parameterMappings = boundSql.getParameterMappings();
    if (parameterMappings != null) {
      Configuration configuration = mappedStatement.getConfiguration();
      TypeHandlerRegistry typeHandlerRegistry = configuration.getTypeHandlerRegistry();
      MetaObject metaObject = (parameterObject == null) ? null : configuration.newMetaObject(parameterObject);
      for (int i = 0; i < parameterMappings.size(); i++) {
        ParameterMapping parameterMapping = parameterMappings.get(i);
        if (parameterMapping.getMode() != ParameterMode.OUT) {
          String propertyName = parameterMapping.getProperty();
          PropertyTokenizer prop = new PropertyTokenizer(propertyName);
          Object value = setParameters(parameterObject, typeHandlerRegistry, boundSql, propertyName, configuration, prop, metaObject);
          TypeHandler typeHandler = parameterMapping.getTypeHandler();
          setParameters(typeHandler, mappedStatement, propertyName);
          typeHandler.setParameter(ps, i + 1, value, parameterMapping.getJdbcType());
        } 
      } 
    } 
  }
  
  private static void setParameters(TypeHandler typeHandler, MappedStatement mappedStatement, String propertyName) {
    if (typeHandler == null)
      throw new ExecutorException("There was no TypeHandler found for parameter " + propertyName + " of statement " + mappedStatement.getId()); 
  }
  
  private Object setParameters(Object parameterObject, TypeHandlerRegistry typeHandlerRegistry, BoundSql boundSql, String propertyName, Configuration configuration, PropertyTokenizer prop, MetaObject metaObject) {
    Object value;
    if (parameterObject == null) {
      value = null;
    } else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) {
      value = parameterObject;
    } else if (boundSql.hasAdditionalParameter(propertyName)) {
      value = boundSql.getAdditionalParameter(propertyName);
    } else if (propertyName.startsWith("__frch_") && boundSql.hasAdditionalParameter(prop.getName())) {
      value = boundSql.getAdditionalParameter(prop.getName());
      if (value != null)
        value = configuration.newMetaObject(value).getValue(propertyName.substring(prop.getName().length())); 
    } else {
      value = (metaObject == null) ? null : metaObject.getValue(propertyName);
    } 
    return value;
  }
  
  public Object plugin(Object target) {
    LOG.debug("plugin");
    return Plugin.wrap(target, this);
  }
  
  public void setProperties(Properties properties) {
    LOG.debug("setProperties");
  }
}

Can you show me just the required modification to perform the migration from log4j to slf4j library please?

write the needed code to perform the migration from log4j to slf4j library. Highlight the code changes needed to adapt the file please.

To perform the migration from Log4j to SLF4J in your Java class, you'll need to modify the import statements and the logger instantiation. Below are the changes highlighted:

1. **Change the import statements** from Log4j to SLF4J.
2. **Update the logger instantiation** to use `LoggerFactory` from SLF4J.

Here's how you can adjust your Java class for SLF4J:

### Original Log4j Setup

```java
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
```

```java
private static final Logger LOG = LogManager.getLogger();
```

### Modified for SLF4J

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
```

```java
private static final Logger LOG = LoggerFactory.getLogger(PageInterceptor.class);
```

### Full Modified Class for SLF4J

```java
package com.llsfw.core.pagequery;

import com.llsfw.core.datasource.DynamicDataSource;
import com.llsfw.core.exception.SystemException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Arrays;
import java.util.List;
import java.util.Properties;
import javax.sql.DataSource;
import org.apache.ibatis.executor.ErrorContext;
import org.apache.ibatis.executor.Executor;
import org.apache.ibatis.executor.ExecutorException;
import org.apache.ibatis.mapping.BoundSql;
import org.apache.ibatis.mapping.MappedStatement;

