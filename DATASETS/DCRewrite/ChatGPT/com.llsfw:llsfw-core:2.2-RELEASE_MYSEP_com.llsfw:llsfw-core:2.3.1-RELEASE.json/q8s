You are a Java code assistant. Given this Java class: 

package com.llsfw.core.common;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.commons.lang3.StringUtils;
import org.apache.http.HttpHost;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class HttpUtil {
  private static final Logger LOG = LogManager.getLogger();
  
  public static String getRemoteAddr(HttpServletRequest request) {
    String remoteAddr = request.getHeader("X-Real-IP");
    if (StringUtils.isEmpty(remoteAddr))
      remoteAddr = request.getHeader("X-Forwarded-For"); 
    if (StringUtils.isEmpty(remoteAddr))
      remoteAddr = request.getHeader("Proxy-Client-IP"); 
    if (StringUtils.isEmpty(remoteAddr))
      remoteAddr = request.getHeader("WL-Proxy-Client-IP"); 
    return (remoteAddr != null) ? remoteAddr : request.getRemoteAddr();
  }
  
  public HttpGet proxy(HttpGet request, String proxyHost, String proxyPort) {
    int connectrequesttimeout = 120000;
    int sockettimeout = 120000;
    int connecttimeout = 120000;
    if (!StringUtils.isEmpty(proxyHost) && !StringUtils.isEmpty(proxyPort)) {
      HttpHost proxy = new HttpHost(proxyHost, (new Integer(proxyPort)).intValue());
      RequestConfig requestConfig = RequestConfig.custom().setProxy(proxy).setConnectionRequestTimeout(connectrequesttimeout).setSocketTimeout(sockettimeout).setConnectTimeout(connecttimeout).build();
      request.setConfig(requestConfig);
    } else {
      RequestConfig requestConfig = RequestConfig.custom().setConnectionRequestTimeout(connectrequesttimeout).setSocketTimeout(sockettimeout).setConnectTimeout(connecttimeout).build();
      request.setConfig(requestConfig);
    } 
    return request;
  }
  
  public HttpPost proxy(HttpPost request, String proxyHost, String proxyPort) {
    if (!StringUtils.isEmpty(proxyHost) && !StringUtils.isEmpty(proxyPort)) {
      HttpHost proxy = new HttpHost(proxyHost, (new Integer(proxyPort)).intValue());
      RequestConfig config = RequestConfig.custom().setProxy(proxy).build();
      request.setConfig(config);
    } 
    return request;
  }
  
  public void download(HttpServletRequest request, HttpServletResponse response, File downloadFile, String fileName) throws IOException {
    long fileLength = downloadFile.length();
    long pastLength = 0L;
    long contentLength = 0L;
    RandomAccessFile raf = null;
    BufferedOutputStream out = null;
    byte[] b = new byte[1024];
    String range = "Range";
    try {
      if (request.getHeader("Range") != null) {
        LOG.info("request.getHeader(\"Range\")=" + request.getHeader("Range"));
        response.setStatus(206);
        String rangeBytes = "";
        rangeBytes = request.getHeader("Range").replaceAll("bytes=", "");
        rangeBytes = rangeBytes.substring(0, rangeBytes.indexOf('-'));
        pastLength = Long.parseLong(rangeBytes.trim());
        contentLength = fileLength - pastLength;
      } else {
        contentLength = fileLength;
      } 
      if (pastLength != 0L) {
        LOG.info("----------------------------);
        String contentRange = "bytes " + Long.toString(pastLength) + "-" + Long.toString(fileLength - 1L) + "/" + Long.toString(fileLength);
        LOG.info("Content-Range:" + contentRange);
        response.setHeader("Content-Range", contentRange);
      } else {
        LOG.info("----------------------------);
      } 
      response.setContentType("application/octet-stream");
      response.setHeader("Accept-Ranges", "bytes");
      LOG.info("Content-Length:" + contentLength);
      response.setHeader("Content-Length", String.valueOf(contentLength));
      response.setHeader("Content-disposition", "attachment; filename=" + new String(fileName.getBytes("UTF-8"), "ISO8859-1"));
      out = new BufferedOutputStream((OutputStream)response.getOutputStream());
      raf = new RandomAccessFile(downloadFile, "r");
      raf.seek(pastLength);
      int n = 0;
      while ((n = raf.read(b, 0, 1024)) != -1)
        out.write(b, 0, n); 
    } catch (IOException e) {
      LOG.info(", e);
      throw new IOException(e);
    } finally {
      out.flush();
      out.close();
      raf.close();
    } 
  }
}



Can you show me just the required modification to perform the migration from log4j to slf4j library please?

To perform the migration from Log4j to SLF4J in the `HttpUtil` class, you need to adjust the logger import and instantiation. Here's how you can do it:

### Modifications Required

**Before (using Log4j):**
```java
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

private static final Logger LOG = LogManager.getLogger();
```

**After (using SLF4J):**
```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

private static final Logger LOG = LoggerFactory.getLogger(HttpUtil.class);
```

Replace the import statement for Log4j with the corresponding import for SLF4J and change the logger instantiation to use `LoggerFactory`. This change ensures that your logging calls remain consistent without changing their usage throughout the `HttpUtil` class.
