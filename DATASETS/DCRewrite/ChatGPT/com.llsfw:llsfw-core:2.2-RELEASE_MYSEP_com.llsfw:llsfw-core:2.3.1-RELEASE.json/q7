To migrate the `Ftp` class from using Log4j to the SLF4J library, the changes involve updating the import statements for the logger and changing how the logger is instantiated. Here's the updated class with these changes:

```java
package com.llsfw.core.security.session.redis;

import com.llsfw.core.security.session.SerializeUtils;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.apache.shiro.cache.Cache;
import org.springframework.util.CollectionUtils;

public class RedisCache<K, V> implements Cache<K, V> {
  private static final Logger LOG = LoggerFactory.getLogger(RedisCache.class);
  
  private DbManager cache;
  
  private String keyPrefix;
  
  public RedisCache(DbManager cache, String prefix) {
    this(cache);
    this.keyPrefix = prefix;
  }
  
  public RedisCache(DbManager cache) {
    if (cache == null)
      throw new IllegalArgumentException("Cache argument cannot be null."); 
    this.cache = cache;
  }
  
  private byte[] getByteKey(K key) {
    if (key instanceof String) {
      String preKey = this.keyPrefix + key;
      return preKey.getBytes();
    } 
    return SerializeUtils.serialize(key);
  }
  
  public V get(K key) {
    LOG.debug("[cache]key [{}]", key);
    if (key == null)
      return null; 
    byte[] rawValue = this.cache.get(getByteKey(key));
    return (V)SerializeUtils.deserialize(rawValue);
  }
  
  public V put(K key, V value) {
    LOG.debug("[cache]key [{}]", key);
    this.cache.set(getByteKey(key), SerializeUtils.serialize(value));
    return value;
  }
  
  public V remove(K key) {
    LOG.debug("[cache]key [{}]", key);
    V previous = get(key);
    this.cache.del(getByteKey(key));
    return previous;
  }
  
  public void clear() {
    LOG.debug("[cache]");
    this.cache.flushDB();
  }
  
  public int size() {
    Long longSize = new Long(this.cache.dbSize());
    return longSize.intValue();
  }
  
  public Set<K> keys() {
    LOG.debug("[cache]");
    Set<byte[]> keys = this.cache.keys(this.keyPrefix + "*");
    if (CollectionUtils.isEmpty(keys))
      return Collections.emptySet(); 
    Set<K> newKeys = new HashSet<>();
    for (byte[] key : keys)
      newKeys.add((K)key); 
    return newKeys;
  }
  
  public Collection<V> values() {
    LOG.debug("[cache]");
    Set<byte[]> keys = this.cache.keys(this.keyPrefix + "*");
    if (!CollectionUtils.isEmpty(keys)) {
      List<V> values = new ArrayList<>(keys.size());
      for (byte[] key : keys) {
        V value = get((K)key);
        if (value != null)
          values.add(value); 
      } 
      return Collections.unmodifiableList(values);
    } 
    return Collections.emptyList();
  }
}
```

### Key Changes:
1. **Logger Import**: Changed from `org.apache.logging.log4j.LogManager` and `org.apache.logging.log4j.Logger` to `org.slf4j.LoggerFactory` and `org.slf4j.Logger`.
2. **Logger Instantiation**: Changed from `LogManager.getLogger()` to `LoggerFactory.getLogger(RedisCache.class)`.
3. **Logging Calls**: Updated the logging calls to use SLF4J's parameterized messages with `{}` as placeholders. This approach prevents unnecessary string concatenation when the log level is disabled.

These changes ensure that the class is compatible with SLF4J, enhancing the flexibility to switch between different logging frameworks by just changing the logger binding.