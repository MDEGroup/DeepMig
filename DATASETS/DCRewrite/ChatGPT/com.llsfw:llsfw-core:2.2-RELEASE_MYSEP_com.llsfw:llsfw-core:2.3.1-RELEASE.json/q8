To migrate the `HttpUtil` class from using Log4j to the SLF4J library, the changes primarily involve updating the import statements and the way the logger is instantiated. Below is the revised class with these changes implemented:

```java
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.apache.commons.lang3.StringUtils;
import org.apache.http.HttpHost;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class HttpUtil {
  private static final Logger LOG = LoggerFactory.getLogger(HttpUtil.class);
  
  public static String getRemoteAddr(HttpServletRequest request) {
    String remoteAddr = request.getHeader("X-Real-IP");
    if (StringUtils.isEmpty(remoteAddr))
      remoteAddr = request.getHeader("X-Forwarded-For"); 
    if (StringUtils.isEmpty(remoteAddr))
      remoteAddr = request.getHeader("Proxy-Client-IP"); 
    if (StringUtils.isEmpty(remoteAddr))
      remoteAddr = request.getHeader("WL-Proxy-Client-IP"); 
    return (remoteAddr != null) ? remoteAddr : request.getRemoteAddr();
  }
  
  public HttpGet proxy(HttpGet request, String proxyHost, String proxyPort) {
    int connectrequesttimeout = 120000;
    int sockettimeout = 120000;
    int connecttimeout = 120000;
    if (!StringUtils.isEmpty(proxyHost) && !StringUtils.isEmpty(proxyPort)) {
      HttpHost proxy = new HttpHost(proxyHost, Integer.parseInt(proxyPort));
      RequestConfig requestConfig = RequestConfig.custom().setProxy(proxy).setConnectionRequestTimeout(connectrequesttimeout).setSocketTimeout(sockettimeout).setConnectTimeout(connecttimeout).build();
      request.setConfig(requestConfig);
    } else {
      RequestConfig requestConfig = RequestConfig.custom().setConnectionRequestTimeout(connectrequesttimeout).setSocketTimeout(sockettimeout).setConnectTimeout(connecttimeout).build();
      request.setConfig(requestConfig);
    } 
    return request;
  }
  
  public HttpPost proxy(HttpPost request, String proxyHost, String proxyPort) {
    if (!StringUtils.isEmpty(proxyHost) && !StringUtils.isEmpty(proxyPort)) {
      HttpHost proxy = new HttpHost(proxyHost, Integer.parseInt(proxyPort));
      RequestConfig config = RequestConfig.custom().setProxy(proxy).build();
      request.setConfig(config);
    } 
    return request;
  }
  
  public void download(HttpServletRequest request, HttpServletResponse response, File downloadFile, String fileName) throws IOException {
    long fileLength = downloadFile.length();
    long pastLength = 0L;
    long contentLength = 0L;
    RandomAccessFile raf = null;
    BufferedOutputStream out = null;
    byte[] b = new byte[1024];
    try {
      if (request.getHeader("Range") != null) {
        response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);
        String rangeBytes = request.getHeader("Range").replaceAll("bytes=", "");
        rangeBytes = rangeBytes.substring(0, rangeBytes.indexOf('-'));
        pastLength = Long.parseLong(rangeBytes.trim());
        contentLength = fileLength - pastLength;
      } else {
        contentLength = fileLength;
      } 
      if (pastLength != 0L) {
        String contentRange = "bytes " + pastLength + "-" + (fileLength - 1) + "/" + fileLength;
        response.setHeader("Content-Range", contentRange);
      } 
      response.setContentType("application/octet-stream");
      response.setHeader("Accept-Ranges", "bytes");
      response.setHeader("Content-Length", String.valueOf(contentLength));
      response.setHeader("Content-Disposition", "attachment; filename=" + new String(fileName.getBytes("UTF-8"), "ISO8859-1"));
      out = new BufferedOutputStream(response.getOutputStream());
      raf = new RandomAccessFile(downloadFile, "r");
      raf.seek(pastLength);
      int n = 0;
      while ((n = raf.read(b, 0, 1024)) != -1) {
        out.write(b, 0, n);
      }
    } finally {
      if (out != null) {
        out.flush();
        out.close();
      }
      if (raf != null) {
        raf.close();
      }
    } 
  }
}
```

### Key Changes:
1. **Logger Import**: Changed from `org.apache.logging.log4j.LogManager` and `org.apache.logging.log4j.Logger` to `org.slf4j.LoggerFactory` and `org.slf4j.Logger`.
2. **Logger Instantiation**: Changed from `LogManager.getLogger()` to `LoggerFactory.getLogger(HttpUtil.class)`.
3. **Logging Calls**: Updated the logging calls to use SLF4J's parameterized messages with `{}` as placeholders

.

These changes convert the class to use SLF4J for logging, which is beneficial for flexibility in logging backends and better practice for dependencies in libraries.