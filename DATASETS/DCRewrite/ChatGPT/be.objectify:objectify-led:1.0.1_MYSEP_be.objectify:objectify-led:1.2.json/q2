You are a Java code assistant. Given this Java class: 

package be.objectify.led;

import be.objectify.led.factory.BooleanFactory;
import be.objectify.led.factory.ByteFactory;
import be.objectify.led.factory.CharacterFactory;
import be.objectify.led.factory.DoubleFactory;
import be.objectify.led.factory.FloatFactory;
import be.objectify.led.factory.IntegerFactory;
import be.objectify.led.factory.LongFactory;
import be.objectify.led.factory.ShortFactory;
import be.objectify.led.factory.StringFactory;
import be.objectify.led.util.ContractUtils;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.log4j.Logger;

public class ObjectFactoryRegistry {
  private static final Logger LOGGER = Logger.getLogger(ObjectFactoryRegistry.class);
  
  private final Map<Class, ObjectFactory> objectFactories = (Map)new HashMap<>();
  
  private static final Map<Class, Class> PRIMITIVE_TO_WRAPPER_MAP = (Map)new HashMap<>();
  
  static {
    PRIMITIVE_TO_WRAPPER_MAP.put(boolean.class, Boolean.class);
    PRIMITIVE_TO_WRAPPER_MAP.put(byte.class, Byte.class);
    PRIMITIVE_TO_WRAPPER_MAP.put(char.class, Character.class);
    PRIMITIVE_TO_WRAPPER_MAP.put(double.class, Double.class);
    PRIMITIVE_TO_WRAPPER_MAP.put(float.class, Float.class);
    PRIMITIVE_TO_WRAPPER_MAP.put(int.class, Integer.class);
    PRIMITIVE_TO_WRAPPER_MAP.put(long.class, Long.class);
    PRIMITIVE_TO_WRAPPER_MAP.put(short.class, Short.class);
  }
  
  public ObjectFactoryRegistry() {
    BooleanFactory booleanFactory = new BooleanFactory();
    this.objectFactories.put(booleanFactory.getBoundClass(), booleanFactory);
    ByteFactory byteFactory = new ByteFactory();
    this.objectFactories.put(byteFactory.getBoundClass(), byteFactory);
    CharacterFactory characterFactory = new CharacterFactory();
    this.objectFactories.put(characterFactory.getBoundClass(), characterFactory);
    DoubleFactory doubleFactory = new DoubleFactory();
    this.objectFactories.put(doubleFactory.getBoundClass(), doubleFactory);
    FloatFactory floatFactory = new FloatFactory();
    this.objectFactories.put(floatFactory.getBoundClass(), floatFactory);
    IntegerFactory integerFactory = new IntegerFactory();
    this.objectFactories.put(integerFactory.getBoundClass(), integerFactory);
    LongFactory longFactory = new LongFactory();
    this.objectFactories.put(longFactory.getBoundClass(), longFactory);
    ShortFactory shortFactory = new ShortFactory();
    this.objectFactories.put(shortFactory.getBoundClass(), shortFactory);
    StringFactory stringFactory = new StringFactory();
    this.objectFactories.put(stringFactory.getBoundClass(), stringFactory);
  }
  
  public void register(ObjectFactory... objectFactories) {
    ContractUtils.nonNull((Object[])objectFactories, "objectFactories");
    register(Arrays.asList(objectFactories));
  }
  
  public void register(List<ObjectFactory> objectFactories) {
    ContractUtils.nonNull(objectFactories, "objectFactories");
    for (ObjectFactory objectFactory : objectFactories)
      this.objectFactories.put(objectFactory.getBoundClass(), objectFactory); 
  }
  
  public ObjectFactory getFactory(Class clazz) {
    if (clazz.isPrimitive())
      clazz = PRIMITIVE_TO_WRAPPER_MAP.get(clazz); 
    ObjectFactory factory = this.objectFactories.get(clazz);
    if (LOGGER.isDebugEnabled())
      if (factory != null) {
        LOGGER.debug(String.format("Found factory [%s] for class [%s]", new Object[] { factory, clazz
                
                .getCanonicalName() }));
      } else {
        LOGGER.debug("Could not find factory for " + clazz.getCanonicalName());
      }  
    return factory;
  }
}


write the needed code to perform the migration from log4j to slf4j library. Highlight the code changes needed to adapt the file please.

To migrate from log4j to slf4j in the `ObjectFactoryRegistry` class, you need to replace the log4j `Logger` with the slf4j `Logger`. Here are the changes needed to adapt the provided class:

### Original Code with log4j
```java
package be.objectify.led;

import be.objectify.led.factory.BooleanFactory;
import be.objectify.led.factory.ByteFactory;
import be.objectify.led.factory.CharacterFactory;
import be.objectify.led.factory.DoubleFactory;
import be.objectify.led.factory.FloatFactory;
import be.objectify.led.factory.IntegerFactory;
import be.objectify.led.factory.LongFactory;
import be.objectify.led.factory.ShortFactory;
import be.objectify.led.factory.StringFactory;
import be.objectify.led.util.ContractUtils;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.log4j.Logger;

public class ObjectFactoryRegistry {
  private static final Logger LOGGER = Logger.getLogger(ObjectFactoryRegistry.class);

  private final Map<Class, ObjectFactory> objectFactories = (Map)new HashMap<>();

  private static final Map<Class, Class> PRIMITIVE_TO_WRAPPER_MAP = (Map)new HashMap<>();

  static {
    PRIMITIVE_TO_WRAPPER_MAP.put(boolean.class, Boolean.class);
    PRIMITIVE_TO_WRAPPER_MAP.put(byte.class, Byte.class);
    PRIMITIVE_TO_WRAPPER_MAP.put(char.class, Character.class);
    PRIMITIVE_TO_WRAPPER_MAP.put(double.class, Double.class);
    PRIMITIVE_TO_WRAPPER_MAP.put(float.class, Float.class);
    PRIMITIVE_TO_WRAPPER_MAP.put(int.class, Integer.class);
    PRIMITIVE_TO_WRAPPER_MAP.put(long.class, Long.class);
    PRIMITIVE_TO_WRAPPER_MAP.put(short.class, Short.class);
  }

  public ObjectFactoryRegistry() {
    BooleanFactory booleanFactory = new BooleanFactory();
    this.objectFactories.put(booleanFactory.getBoundClass(), booleanFactory);
    ByteFactory byteFactory = new ByteFactory();
    this.objectFactories.put(byteFactory.getBoundClass(), byteFactory);
    CharacterFactory characterFactory = new CharacterFactory();
    this.objectFactories.put(characterFactory.getBoundClass(), characterFactory);
    DoubleFactory doubleFactory = new DoubleFactory();
    this.objectFactories.put(doubleFactory.getBoundClass(), doubleFactory);
    FloatFactory floatFactory = new FloatFactory();
    this.objectFactories.put(floatFactory.getBoundClass(), floatFactory);
    IntegerFactory integerFactory = new IntegerFactory();
    this.objectFactories.put(integerFactory.getBoundClass(), integerFactory);
    LongFactory longFactory = new LongFactory();
    this.objectFactories.put(longFactory.getBoundClass(), longFactory);
    ShortFactory shortFactory = new ShortFactory();
    this.objectFactories.put(shortFactory.getBoundClass(), shortFactory);
    StringFactory stringFactory = new StringFactory();
    this.objectFactories.put(stringFactory.getBoundClass(), stringFactory);
  }

  public void register(ObjectFactory... objectFactories) {
    ContractUtils.nonNull((Object[])objectFactories, "objectFactories");
    register(Arrays.asList(objectFactories));
  }

  public void register(List<ObjectFactory> objectFactories) {
    ContractUtils.nonNull(objectFactories, "objectFactories");
    for (ObjectFactory objectFactory : objectFactories)
      this.objectFactories.put(objectFactory.getBoundClass(), objectFactory);
  }

  public ObjectFactory getFactory(Class clazz) {
    if (clazz.isPrimitive())
      clazz = PRIMITIVE_TO_WRAPPER_MAP.get(clazz);
    ObjectFactory factory = this.objectFactories.get(clazz);
    if (LOGGER.isDebugEnabled())
      if (factory != null) {
        LOGGER.debug(String.format("Found factory [%s] for class [%s]", new Object[] { factory, clazz

                .getCanonicalName() }));
      } else {
        LOGGER.debug("Could not find factory for " + clazz.getCanonicalName());
      }
    return factory;
  }
}
```

### Modified Code with slf4j
```java
package be.objectify.led;

import be.objectify.led.factory.BooleanFactory;
import be.objectify.led.factory.ByteFactory;
import be.objectify.led.factory.CharacterFactory;
import be.objectify.led.factory.DoubleFactory;
import be.objectify.led.factory.FloatFactory;
import be.objectify.led.factory.IntegerFactory;
import be.objectify.led.factory.LongFactory;
import be.objectify.led.factory.ShortFactory;
import be.objectify.led.factory.StringFactory;
import be.objectify.led.util.ContractUtils;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ObjectFactoryRegistry {
  private static final Logger LOGGER = LoggerFactory.getLogger(ObjectFactoryRegistry.class);

  private final Map<Class, ObjectFactory> objectFactories = new HashMap<>();

  private static final Map<Class, Class> PRIMITIVE_TO_WRAPPER_MAP = new HashMap<>();

  static {
    PRIMITIVE_TO_WRAPPER_MAP.put(boolean.class, Boolean.class);
    PRIMITIVE_TO_WRAPPER_MAP.put(byte.class, Byte.class);
    PRIMITIVE_TO_WRAPPER_MAP.put(char.class, Character.class);
    PRIMITIVE_TO_WRAPPER_MAP.put(double.class, Double.class);
    PRIMITIVE_TO_WRAPPER_MAP.put(float.class, Float.class);
    PRIMITIVE_TO_WRAPPER_MAP.put(int.class, Integer.class);
    PRIMITIVE_TO_WRAPPER_MAP.put(long.class, Long.class);
    PRIMITIVE_TO_WRAPPER_MAP.put(short.class, Short.class);
  }

  public ObjectFactoryRegistry() {
    BooleanFactory booleanFactory = new BooleanFactory();
    this.objectFactories.put(booleanFactory.getBoundClass(), booleanFactory);
    ByteFactory byteFactory = new ByteFactory();
    this.objectFactories.put(byteFactory.getBoundClass(), byteFactory);
    CharacterFactory characterFactory = new CharacterFactory();
    this.objectFactories.put(characterFactory.getBoundClass(), characterFactory);
    DoubleFactory doubleFactory = new DoubleFactory();
    this.objectFactories.put(doubleFactory.getBoundClass(), doubleFactory);
    FloatFactory floatFactory = new FloatFactory();
    this.objectFactories.put(floatFactory.getBoundClass(), floatFactory);
    IntegerFactory integerFactory = new IntegerFactory();
    this.objectFactories.put(integerFactory.getBoundClass(), integerFactory);
    LongFactory longFactory = new LongFactory();
    this.objectFactories.put(longFactory.getBoundClass(), longFactory);
    ShortFactory shortFactory = new ShortFactory();
    this.objectFactories.put(shortFactory.getBoundClass(), shortFactory);
    StringFactory stringFactory = new StringFactory();
    this.objectFactories.put(stringFactory.getBoundClass(), stringFactory);
  }

  public void register(ObjectFactory... objectFactories) {
    ContractUtils.nonNull((Object[])objectFactories, "objectFactories");
    register(Arrays.asList(objectFactories));
  }

  public void register(List<ObjectFactory> objectFactories) {
    ContractUtils.nonNull(objectFactories, "objectFactories");
    for (ObjectFactory objectFactory : objectFactories)
      this.objectFactories.put(objectFactory.getBoundClass(), objectFactory);
  }

  public ObjectFactory getFactory(Class clazz) {
    if (clazz.isPrimitive())
      clazz = PRIMITIVE_TO_WRAPPER_MAP.get(clazz);
    ObjectFactory factory = this.objectFactories.get(clazz);
    if (LOGGER.isDebugEnabled())
      if (factory != null) {
        LOGGER.debug(String.format("Found factory [%s] for class [%s]", factory, clazz.getCanonicalName()));
      } else {
        LOGGER.debug("Could not find factory for " + clazz.getCanonicalName());
      }
    return factory;
  }
}
```

### Highlighted Changes
1. Import changes:
    ```java
    import org.apache.log4j.Logger;
    ```
    is replaced by:
    ```java
    import org.slf4j.Logger;
    import org.slf4j.LoggerFactory;
    ```

2. Logger initialization:
    ```java
    private static final Logger LOGGER = Logger.getLogger(ObjectFactoryRegistry.class);
    ```
    is replaced by:
    ```java
    private static final Logger LOGGER = LoggerFactory.getLogger(ObjectFactoryRegistry.class);
    ```

3. Type casting for `objectFactories` and `PRIMITIVE_TO_WRAPPER_MAP` maps:
    ```java
    private final Map<Class, ObjectFactory> objectFactories = (Map)new HashMap<>();
    private static final Map<Class, Class> PRIMITIVE_TO_WRAPPER_MAP = (Map)new HashMap<>();
    ```
    is replaced by:
    ```java
    private final Map<Class, ObjectFactory> objectFactories = new HashMap<>();
    private static final Map<Class, Class> PRIMITIVE_TO_WRAPPER_MAP = new HashMap<>();
    ```

These changes ensure that the logging mechanism is switched from log4j to slf4j, allowing for a more flexible and widely compatible logging framework.

To migrate from log4j to slf4j in the `ObjectFactoryRegistry` class, you need to replace the log4j `Logger` with the slf4j `Logger`. Here are the changes needed to adapt the provided class:

### Original Code with log4j
	```java
	package be.objectify.led;

	import be.objectify.led.factory.BooleanFactory;
	import be.objectify.led.factory.ByteFactory;
	import be.objectify.led.factory.CharacterFactory;
	import be.objectify.led.factory.DoubleFactory;
	import be.objectify.led.factory.FloatFactory;
	import be.objectify.led.factory.IntegerFactory;
	import be.objectify.led.factory.LongFactory;
	import be.objectify.led.factory.ShortFactory;
	import be.objectify.led.factory.StringFactory;
	import be.objectify.led.util.ContractUtils;
	import java.util.Arrays;
	import java.util.HashMap;
	import java.util.List;
	import java.util.Map;
	import org.apache.log4j.Logger;

	public class ObjectFactoryRegistry {
		  private static final Logger LOGGER = Logger.getLogger(ObjectFactoryRegistry.class);
		    
		    private final Map<Class, ObjectFactory> objectFactories = (Map)new HashMap<>();
		      
		      private static final Map<Class, Class> PRIMITIVE_TO_WRAPPER_MAP = (Map)new HashMap<>();
		        
		        static {
				    PRIMITIVE_TO_WRAPPER_MAP.put(boolean.class, Boolean.class);
				        PRIMITIVE_TO_WRAPPER_MAP.put(byte.class, Byte.class);
					    PRIMITIVE_TO_WRAPPER_MAP.put(char.class, Character.class);
					        PRIMITIVE_TO_WRAPPER_MAP.put(double.class, Double.class);
						    PRIMITIVE_TO_WRAPPER_MAP.put(float.class, Float.class);
						        PRIMITIVE_TO_WRAPPER_MAP.put(int.class, Integer.class);
							    PRIMITIVE_TO_WRAPPER_MAP.put(long.class, Long.class);
							        PRIMITIVE_TO_WRAPPER_MAP.put(short.class, Short.class);
								  }
			  
			  public ObjectFactoryRegistry() {
				      BooleanFactory booleanFactory = new BooleanFactory();
				          this.objectFactories.put(booleanFactory.getBoundClass(), booleanFactory);
					      ByteFactory byteFactory = new ByteFactory();
					          this.objectFactories.put(byteFactory.getBoundClass(), byteFactory);
						      CharacterFactory characterFactory = new CharacterFactory();
						          this.objectFactories.put(characterFactory.getBoundClass(), characterFactory);
							      DoubleFactory doubleFactory = new DoubleFactory();
							          this.objectFactories.put(doubleFactory.getBoundClass(), doubleFactory);
								      FloatFactory floatFactory = new FloatFactory();
								          this.objectFactories.put(floatFactory.getBoundClass(), floatFactory);
									      IntegerFactory integerFactory = new IntegerFactory();
									          this.objectFactories.put(integerFactory.getBoundClass(), integerFactory);
										      LongFactory longFactory = new LongFactory();
										          this.objectFactories.put(longFactory.getBoundClass(), longFactory);
											      ShortFactory shortFactory = new ShortFactory();
											          this.objectFactories.put(shortFactory.getBoundClass(), shortFactory);
												      StringFactory stringFactory = new StringFactory();
												          this.objectFactories.put(stringFactory.getBoundClass(), stringFactory);
													    }
			    
			    public void register(ObjectFactory... objectFactories) {
				        ContractUtils.nonNull((Object[])objectFactories, "objectFactories");
					    register(Arrays.asList(objectFactories));
					      }
			      
			      public void register(List<ObjectFactory> objectFactories) {
				          ContractUtils.nonNull(objectFactories, "objectFactories");
					      for (ObjectFactory objectFactory : objectFactories)
						            this.objectFactories.put(objectFactory.getBoundClass(), objectFactory); 
					        }
			        
			        public ObjectFactory getFactory(Class clazz) {
					    if (clazz.isPrimitive())
						          clazz = PRIMITIVE_TO_WRAPPER_MAP.get(clazz); 
					        ObjectFactory factory = this.objectFactories.get(clazz);
						    if (LOGGER.isDebugEnabled())
							          if (factory != null) {
									          LOGGER.debug(String.format("Found factory [%s] for class [%s]", new Object[] { factory, clazz
													                  
													                  .getCanonicalName() }));
										        } else {
												        LOGGER.debug("Could not find factory for " + clazz.getCanonicalName());
													      }  
						        return factory;
							  }
	}
```

### Modified Code with slf4j
```java
package be.objectify.led;

import be.objectify.led.factory.BooleanFactory;
import be.objectify.led.factory.ByteFactory;
import be.objectify.led.factory.CharacterFactory;
import be.objectify.led.factory.DoubleFactory;
import be.objectify.led.factory.FloatFactory;
import be.objectify.led.factory.IntegerFactory;
import be.objectify.led.factory.LongFactory;
import be.objectify.led.factory.ShortFactory;
import be.objectify.led.factory.StringFactory;
import be.objectify.led.util.ContractUtils;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class ObjectFactoryRegistry {
	  private static final Logger LOGGER = LoggerFactory.getLogger(ObjectFactoryRegistry.class);
	    
	    private final Map<Class, ObjectFactory> objectFactories = new HashMap<>();
	      
	      private static final Map<Class, Class> PRIMITIVE_TO_WRAPPER_MAP = new HashMap<>();
	        
	        static {
			    PRIMITIVE_TO_WRAPPER_MAP.put(boolean.class, Boolean.class);
			        PRIMITIVE_TO_WRAPPER_MAP.put(byte.class, Byte.class);
				    PRIMITIVE_TO_WRAPPER_MAP.put(char.class, Character.class);
				        PRIMITIVE_TO_WRAPPER_MAP.put(double.class, Double.class);
					    PRIMITIVE_TO_WRAPPER_MAP.put(float.class, Float.class);
					        PRIMITIVE_TO_WRAPPER_MAP.put(int.class, Integer.class);
						    PRIMITIVE_TO_WRAPPER_MAP.put(long.class, Long.class);
						        PRIMITIVE_TO_WRAPPER_MAP.put(short.class, Short.class);
							  }
		  
		  public ObjectFactoryRegistry() {
			      BooleanFactory booleanFactory = new BooleanFactory();
			          this.objectFactories.put(booleanFactory.getBoundClass(), booleanFactory);
				      ByteFactory byteFactory = new ByteFactory();
				          this.objectFactories.put(byteFactory.getBoundClass(), byteFactory);
					      CharacterFactory characterFactory = new CharacterFactory();
					          this.objectFactories.put(characterFactory.getBoundClass(), characterFactory);
						      DoubleFactory doubleFactory = new DoubleFactory();
						          this.objectFactories.put(doubleFactory.getBoundClass(), doubleFactory);
							      FloatFactory floatFactory = new FloatFactory();
							          this.objectFactories.put(floatFactory.getBoundClass(), floatFactory);
								      IntegerFactory integerFactory = new IntegerFactory();
								          this.objectFactories.put(integerFactory.getBoundClass(), integerFactory);
									      LongFactory longFactory = new LongFactory();
									          this.objectFactories.put(longFactory.getBoundClass(), longFactory);
										      ShortFactory shortFactory = new ShortFactory();
										          this.objectFactories.put(shortFactory.getBoundClass(), shortFactory);
											      StringFactory stringFactory = new StringFactory();
											          this.objectFactories.put(stringFactory.getBoundClass(), stringFactory);
												    }
		    
		    public void register(ObjectFactory... objectFactories) {
			        ContractUtils.nonNull((Object[])objectFactories, "objectFactories");
				    register(Arrays.asList(objectFactories));
				      }
		      
		      public void register(List<ObjectFactory> objectFactories) {
			          ContractUtils.nonNull(objectFactories, "objectFactories");
				      for (ObjectFactory objectFactory : objectFactories)
					            this.objectFactories.put(objectFactory.getBoundClass(), objectFactory); 
				        }
		        
		        public ObjectFactory getFactory(Class clazz) {
				    if (clazz.isPrimitive())
					          clazz = PRIMITIVE_TO_WRAPPER_MAP.get(clazz); 
				        ObjectFactory factory = this.objectFactories.get(clazz);
					    if (LOGGER.isDebugEnabled())
						          if (factory != null) {
								          LOGGER.debug(String.format("Found factory [%s] for class [%s]", factory, clazz.getCanonicalName()));
									        } else {
											        LOGGER.debug("Could not find factory for " + clazz.getCanonicalName());
												      }  
					        return factory;
						  }
}
```

### Highlighted Changes
1. Import changes:
    ```java
        import org.apache.log4j.Logger;
	    ```
	        is replaced by:
		    ```java
		        import org.slf4j.Logger;
			    import org.slf4j.LoggerFactory;
			        ```

				2. Logger initialization:
				    ```java
				        private static final Logger LOGGER = Logger.getLogger(ObjectFactoryRegistry.class);
					    ```
					        is replaced by:
						    ```java
						        private static final Logger LOGGER = LoggerFactory.getLogger(ObjectFactoryRegistry.class);
							    ```

							    3. Type casting for `objectFactories` and `PRIMITIVE_TO_WRAPPER_MAP` maps:
							        ```java
								    private final Map<Class, ObjectFactory> objectFactories = (Map)new HashMap<>();
								        private static final Map<Class, Class> PRIMITIVE_TO_WRAPPER_MAP = (Map)new HashMap<>();
									    ```
									        is replaced by:
										    ```java
										        private final Map<Class, ObjectFactory> objectFactories = new HashMap<>();
											    private static final Map<Class, Class> PRIMITIVE_TO_WRAPPER_MAP = new HashMap<>();
											        ```

												These changes ensure that the logging mechanism is switched from log4j to slf4j, allowing for a more flexible and widely compatible logging framework.
