You are a Java code assistant. Given this Java class: 

package be.objectify.led;

import be.objectify.led.util.ContractUtils;
import be.objectify.led.util.StringUtils;
import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import org.apache.log4j.Logger;

public class PropertySetter {
  private static final Logger LOGGER = Logger.getLogger(PropertySetter.class);
  
  private final ObjectFactoryRegistry objectFactoryRegistry;
  
  private final PropertyContext propertyContext;
  
  public PropertySetter() {
    this(new ObjectFactoryRegistry(), new DefaultPropertyContext(new java.util.Properties[0]));
  }
  
  public PropertySetter(PropertyContext propertyContext) {
    this(new ObjectFactoryRegistry(), propertyContext);
  }
  
  public PropertySetter(ObjectFactoryRegistry objectFactoryRegistry) {
    this(objectFactoryRegistry, new DefaultPropertyContext(new java.util.Properties[0]));
  }
  
  public PropertySetter(ObjectFactoryRegistry objectFactoryRegistry, PropertyContext propertyContext) {
    ContractUtils.notNull(objectFactoryRegistry, "objectFactoryRegistry");
    ContractUtils.notNull(propertyContext, "propertyContext");
    this.objectFactoryRegistry = objectFactoryRegistry;
    this.propertyContext = propertyContext;
  }
  
  public void process(Class target) {
    Field[] fields = target.getDeclaredFields();
    for (Field field : fields) {
      if (field.isAnnotationPresent((Class)Property.class) && 
        Modifier.isStatic(field.getModifiers()))
        setProperty(target, field); 
    } 
  }
  
  public void process(Object target) {
    Field[] fields = target.getClass().getDeclaredFields();
    for (Field field : fields) {
      if (field.isAnnotationPresent((Class)Property.class))
        setProperty(target, field); 
    } 
  }
  
  private void setProperty(Object target, Field field) {
    String propertyValue = getProperty(field);
    if (!StringUtils.isEmpty(propertyValue) && 
      !Modifier.isFinal(field.getModifiers())) {
      Class<?> type = field.getType();
      ObjectFactory objectFactory = this.objectFactoryRegistry.getFactory(type);
      if (objectFactory != null)
        setValue(target, field, objectFactory
            
            .createObject(propertyValue)); 
    } 
  }
  
  private void setValue(Object target, Field field, Object value) {
    if (value != null)
      try {
        boolean accessibleState = field.isAccessible();
        if (!accessibleState)
          field.setAccessible(true); 
        field.set(target, value);
        field.setAccessible(accessibleState);
      } catch (IllegalAccessException e) {
        LOGGER.error("Unable to set property", e);
      }  
  }
  
  private String getProperty(AccessibleObject accessibleObject) {
    Property annotation = accessibleObject.<Property>getAnnotation(Property.class);
    String propertyName = annotation.value();
    String propertyValue = this.propertyContext.getValue(propertyName);
    if (LOGGER.isDebugEnabled() && !StringUtils.isEmpty(propertyValue))
      LOGGER.debug(String.format("Found value [%s] for system property [%s] on [%s]", new Object[] { propertyValue, propertyName, accessibleObject
              
              .toString() })); 
    return propertyValue;
  }
}

write the needed code to perform the migration from log4j to slf4j library. Highlight the code changes needed to adapt the file please.

To migrate from log4j to slf4j, you need to replace the log4j `Logger` with the slf4j `Logger`. Here are the changes needed to adapt the provided class `PropertySetter`:

### Original Code with log4j
```java
package be.objectify.led;

import be.objectify.led.util.ContractUtils;
import be.objectify.led.util.StringUtils;
import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import org.apache.log4j.Logger;

public class PropertySetter {
  private static final Logger LOGGER = Logger.getLogger(PropertySetter.class);

  private final ObjectFactoryRegistry objectFactoryRegistry;

  private final PropertyContext propertyContext;

  public PropertySetter() {
    this(new ObjectFactoryRegistry(), new DefaultPropertyContext(new java.util.Properties[0]));
  }

  public PropertySetter(PropertyContext propertyContext) {
    this(new ObjectFactoryRegistry(), propertyContext);
  }

  public PropertySetter(ObjectFactoryRegistry objectFactoryRegistry) {
    this(objectFactoryRegistry, new DefaultPropertyContext(new java.util.Properties[0]));
  }

  public PropertySetter(ObjectFactoryRegistry objectFactoryRegistry, PropertyContext propertyContext) {
    ContractUtils.notNull(objectFactoryRegistry, "objectFactoryRegistry");
    ContractUtils.notNull(propertyContext, "propertyContext");
    this.objectFactoryRegistry = objectFactoryRegistry;
    this.propertyContext = propertyContext;
  }

  public void process(Class target) {
    Field[] fields = target.getDeclaredFields();
    for (Field field : fields) {
      if (field.isAnnotationPresent((Class)Property.class) &&
        Modifier.isStatic(field.getModifiers()))
        setProperty(target, field);
    }
  }

  public void process(Object target) {
    Field[] fields = target.getClass().getDeclaredFields();
    for (Field field : fields) {
      if (field.isAnnotationPresent((Class)Property.class))
        setProperty(target, field);
    }
  }

  private void setProperty(Object target, Field field) {
    String propertyValue = getProperty(field);
    if (!StringUtils.isEmpty(propertyValue) &&
      !Modifier.isFinal(field.getModifiers())) {
      Class<?> type = field.getType();
      ObjectFactory objectFactory = this.objectFactoryRegistry.getFactory(type);
      if (objectFactory != null)
        setValue(target, field, objectFactory

            .createObject(propertyValue));
    }
  }

  private void setValue(Object target, Field field, Object value) {
    if (value != null)
      try {
        boolean accessibleState = field.isAccessible();
        if (!accessibleState)
          field.setAccessible(true);
        field.set(target, value);
        field.setAccessible(accessibleState);
      } catch (IllegalAccessException e) {
        LOGGER.error("Unable to set property", e);
      }
  }

  private String getProperty(AccessibleObject accessibleObject) {
    Property annotation = accessibleObject.<Property>getAnnotation(Property.class);
    String propertyName = annotation.value();
    String propertyValue = this.propertyContext.getValue(propertyName);
    if (LOGGER.isDebugEnabled() && !StringUtils.isEmpty(propertyValue))
      LOGGER.debug(String.format("Found value [%s] for system property [%s] on [%s]", new Object[] { propertyValue, propertyName, accessibleObject

              .toString() }));
    return propertyValue;
  }
}
```

### Modified Code with slf4j
```java
package be.objectify.led;

import be.objectify.led.util.ContractUtils;
import be.objectify.led.util.StringUtils;
import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class PropertySetter {
  private static final Logger LOGGER = LoggerFactory.getLogger(PropertySetter.class);

  private final ObjectFactoryRegistry objectFactoryRegistry;

  private final PropertyContext propertyContext;

  public PropertySetter() {
    this(new ObjectFactoryRegistry(), new DefaultPropertyContext(new java.util.Properties[0]));
  }

  public PropertySetter(PropertyContext propertyContext) {
    this(new ObjectFactoryRegistry(), propertyContext);
  }

  public PropertySetter(ObjectFactoryRegistry objectFactoryRegistry) {
    this(objectFactoryRegistry, new DefaultPropertyContext(new java.util.Properties[0]));
  }

  public PropertySetter(ObjectFactoryRegistry objectFactoryRegistry, PropertyContext propertyContext) {
    ContractUtils.notNull(objectFactoryRegistry, "objectFactoryRegistry");
    ContractUtils.notNull(propertyContext, "propertyContext");
    this.objectFactoryRegistry = objectFactoryRegistry;
    this.propertyContext = propertyContext;
  }

  public void process(Class target) {
    Field[] fields = target.getDeclaredFields();
    for (Field field : fields) {
      if (field.isAnnotationPresent((Class)Property.class) &&
        Modifier.isStatic(field.getModifiers()))
        setProperty(target, field);
    }
  }

  public void process(Object target) {
    Field[] fields = target.getClass().getDeclaredFields();
    for (Field field : fields) {
      if (field.isAnnotationPresent((Class)Property.class))
        setProperty(target, field);
    }
  }

  private void setProperty(Object target, Field field) {
    String propertyValue = getProperty(field);
    if (!StringUtils.isEmpty(propertyValue) &&
      !Modifier.isFinal(field.getModifiers())) {
      Class<?> type = field.getType();
      ObjectFactory objectFactory = this.objectFactoryRegistry.getFactory(type);
      if (objectFactory != null)
        setValue(target, field, objectFactory.createObject(propertyValue));
    }
  }

  private void setValue(Object target, Field field, Object value) {
    if (value != null)
      try {
        boolean accessibleState = field.isAccessible();
        if (!accessibleState)
          field.setAccessible(true);
        field.set(target, value);
        field.setAccessible(accessibleState);
      } catch (IllegalAccessException e) {
        LOGGER.error("Unable to set property", e);
      }
  }

  private String getProperty(AccessibleObject accessibleObject) {
    Property annotation = accessibleObject.<Property>getAnnotation(Property.class);
    String propertyName = annotation.value();
    String propertyValue = this.propertyContext.getValue(propertyName);
    if (LOGGER.isDebugEnabled() && !StringUtils.isEmpty(propertyValue))
      LOGGER.debug(String.format("Found value [%s] for system property [%s] on [%s]", new Object[] { propertyValue, propertyName, accessibleObject.toString() }));
    return propertyValue;
  }
}
```

### Highlighted Changes
1. Import changes:
    ```java
    import org.apache.log4j.Logger;
    ```
    is replaced by:
    ```java
    import org.slf4j.Logger;
    import org.slf4j.LoggerFactory;
    ```

2. Logger initialization:
    ```java
    private static final Logger LOGGER = Logger.getLogger(PropertySetter.class);
    ```
    is replaced by:
    ```java
    private static final Logger LOGGER = LoggerFactory.getLogger(PropertySetter.class);
    ```

These changes ensure that the logging mechanism is switched from log4j to slf4j, allowing for a more flexible and widely compatible logging framework.
