You are a Java code assistant. Given this Java class: 

package com.omertron.fanarttvapi;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.TreeNode;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.omertron.fanarttvapi.model.FTArtworkSort;
import com.omertron.fanarttvapi.model.FTArtworkType;
import com.omertron.fanarttvapi.model.FanartTvArtwork;
import com.omertron.fanarttvapi.model.WrapperMovie;
import com.omertron.fanarttvapi.model.WrapperMusic;
import com.omertron.fanarttvapi.model.WrapperSeries;
import com.omertron.fanarttvapi.tools.FilteringLayout;
import com.omertron.fanarttvapi.tools.WebBrowser;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.apache.log4j.Logger;

public class FanartTvApi {
  private static final Logger logger = Logger.getLogger(FanartTvApi.class);
  
  private String apiKey;
  
  private static final String API_FORMAT = "json";
  
  private static final String ERROR_JSON_TEXT = "Failed processing JSON Node";
  
  private static final String API_SITE = "http://api.fanart.tv/webservice/";
  
  private static final String API_SERIES = "series/";
  
  private static final String API_MOVIE = "movie/";
  
  private static final String API_MUSIC = "artist/";
  
  private static final int DEFAULT_ARTWORK_LIMIT = 2;
  
  private static final FTArtworkType DEFAULT_ARTWORK_TYPE = FTArtworkType.ALL;
  
  private static ObjectMapper mapper = new ObjectMapper();
  
  public FanartTvApi(String apiKey) {
    this.apiKey = apiKey;
    FilteringLayout.addApiKey(apiKey);
  }
  
  private List<FanartTvArtwork> readTvArtwork(String searchUrl) throws FanartTvException {
    JsonNode jn = getJsonNode(searchUrl);
    Iterator<String> ftNode = jn.fieldNames();
    if (ftNode.hasNext()) {
      WrapperSeries wrapper;
      try {
        wrapper = (WrapperSeries)mapper.treeToValue((TreeNode)jn.get(ftNode.next()), WrapperSeries.class);
      } catch (JsonParseException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (JsonMappingException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (IOException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } 
      ArrayList<FanartTvArtwork> artworkList = new ArrayList<FanartTvArtwork>();
      for (Map.Entry<FTArtworkType, List<FanartTvArtwork>> entry : (Iterable<Map.Entry<FTArtworkType, List<FanartTvArtwork>>>)wrapper.getArtwork().entrySet()) {
        if (entry.getValue() != null && !((List)entry.getValue()).isEmpty())
          for (FanartTvArtwork ftSingle : entry.getValue()) {
            ftSingle.setType(entry.getKey());
            artworkList.add(ftSingle);
          }  
      } 
      return artworkList;
    } 
    return Collections.EMPTY_LIST;
  }
  
  private List<FanartTvArtwork> readMovieArtwork(String searchUrl) throws FanartTvException {
    JsonNode jn = getJsonNode(searchUrl);
    Iterator<String> ftNode = jn.fieldNames();
    if (ftNode.hasNext()) {
      WrapperMovie wrapper;
      try {
        wrapper = (WrapperMovie)mapper.treeToValue((TreeNode)jn.get(ftNode.next()), WrapperMovie.class);
      } catch (JsonParseException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (JsonMappingException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (IOException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } 
      ArrayList<FanartTvArtwork> artworkList = new ArrayList<FanartTvArtwork>();
      for (Map.Entry<FTArtworkType, List<FanartTvArtwork>> entry : (Iterable<Map.Entry<FTArtworkType, List<FanartTvArtwork>>>)wrapper.getArtwork().entrySet()) {
        if (entry.getValue() != null && !((List)entry.getValue()).isEmpty())
          for (FanartTvArtwork ftSingle : entry.getValue()) {
            ftSingle.setType(entry.getKey());
            artworkList.add(ftSingle);
          }  
      } 
      return artworkList;
    } 
    return Collections.EMPTY_LIST;
  }
  
  public List<FanartTvArtwork> readMusicArtwork(String searchUrl) throws FanartTvException {
    JsonNode jn = getJsonNode(searchUrl);
    Iterator<String> ftNode = jn.fieldNames();
    if (ftNode.hasNext()) {
      WrapperMusic wrapper;
      try {
        wrapper = (WrapperMusic)mapper.treeToValue((TreeNode)jn.get(ftNode.next()), WrapperMusic.class);
      } catch (JsonParseException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (JsonMappingException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (IOException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } 
      ArrayList<FanartTvArtwork> artworkList = new ArrayList<FanartTvArtwork>();
      for (Map.Entry<FTArtworkType, List<FanartTvArtwork>> entry : (Iterable<Map.Entry<FTArtworkType, List<FanartTvArtwork>>>)wrapper.getArtwork().entrySet()) {
        if (!((List)entry.getValue()).isEmpty())
          for (FanartTvArtwork ftSingle : entry.getValue()) {
            ftSingle.setType(entry.getKey());
            artworkList.add(ftSingle);
          }  
      } 
      return artworkList;
    } 
    return Collections.EMPTY_LIST;
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) throws FanartTvException {
    return readTvArtwork(buildSeriesUrl(tvdbId, artworkType, artworkSortBy, artworkLimit));
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy) throws FanartTvException {
    return getTvArtwork(tvdbId, artworkType, artworkSortBy, 2);
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId, FTArtworkType artworkType) throws FanartTvException {
    return getTvArtwork(tvdbId, artworkType, FTArtworkSort.DEFAULT);
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId) throws FanartTvException {
    return getTvArtwork(tvdbId, DEFAULT_ARTWORK_TYPE);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(int tmdbId) throws FanartTvException {
    return getMovieArtwork(tmdbId, DEFAULT_ARTWORK_TYPE);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(int tmdbId, FTArtworkType artworkType) throws FanartTvException {
    return getMovieArtwork(tmdbId, artworkType, FTArtworkSort.DEFAULT);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(int tmdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy) throws FanartTvException {
    return getMovieArtwork(tmdbId, artworkType, artworkSortBy, 2);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(int tmdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) throws FanartTvException {
    return readMovieArtwork(buildMovieUrl(tmdbId, artworkType, artworkSortBy, artworkLimit));
  }
  
  public List<FanartTvArtwork> getMovieArtwork(String imdbId) throws FanartTvException {
    return getMovieArtwork(imdbId, DEFAULT_ARTWORK_TYPE);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(String imdbId, FTArtworkType artworkType) throws FanartTvException {
    return getMovieArtwork(imdbId, artworkType, FTArtworkSort.DEFAULT);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(String imdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy) throws FanartTvException {
    return getMovieArtwork(imdbId, artworkType, artworkSortBy, 2);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(String imdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) throws FanartTvException {
    return readMovieArtwork(buildMovieUrl(imdbId, artworkType, artworkSortBy, artworkLimit));
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String musicId, FTArtworkType artworkType, FTArtworkSort artworkSort, int artworkLimit) throws FanartTvException {
    return readMusicArtwork(buildMusicUrl(musicId, artworkType, artworkSort, artworkLimit));
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String musicId, FTArtworkType artworkType, FTArtworkSort artworkSort) throws FanartTvException {
    return getMusicArtwork(musicId, artworkType, artworkSort, 2);
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String musicId, FTArtworkType artworkType) throws FanartTvException {
    return getMusicArtwork(musicId, artworkType, FTArtworkSort.DEFAULT);
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String musicId) throws FanartTvException {
    return getMusicArtwork(musicId, DEFAULT_ARTWORK_TYPE);
  }
  
  public void setProxy(String host, String port, String username, String password) {
    WebBrowser.setProxyHost(host);
    WebBrowser.setProxyPort(port);
    WebBrowser.setProxyUsername(username);
    WebBrowser.setProxyPassword(password);
  }
  
  public void setTimeout(int webTimeoutConnect, int webTimeoutRead) {
    WebBrowser.setWebTimeoutConnect(webTimeoutConnect);
    WebBrowser.setWebTimeoutRead(webTimeoutRead);
  }
  
  private String buildUrl(String baseUrl, String artworkId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    StringBuilder searchUrl = new StringBuilder("http://api.fanart.tv/webservice/");
    searchUrl.append(baseUrl);
    searchUrl.append(this.apiKey).append("/");
    searchUrl.append(artworkId).append("/");
    searchUrl.append("json").append("/");
    searchUrl.append(artworkType.toString().toLowerCase()).append("/");
    searchUrl.append(artworkSortBy.getValue()).append("/");
    if (artworkLimit > 0)
      searchUrl.append(Math.max(artworkLimit, 2)).append("/"); 
    logger.trace("Search URL: " + searchUrl);
    return searchUrl.toString();
  }
  
  private String buildSeriesUrl(int tvdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    String idString = String.valueOf((tvdbId < 0) ? 0 : tvdbId);
    return buildUrl("series/", idString, artworkType, artworkSortBy, artworkLimit);
  }
  
  private String buildMovieUrl(int tmdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    String idString = String.valueOf((tmdbId < 0) ? 0 : tmdbId);
    return buildMovieUrl(idString, artworkType, artworkSortBy, artworkLimit);
  }
  
  private String buildMovieUrl(String imdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    return buildUrl("movie/", imdbId, artworkType, artworkSortBy, artworkLimit);
  }
  
  private String buildMusicUrl(String musicId, FTArtworkType artworkType, FTArtworkSort artworkSort, int artworkLimit) {
    return buildUrl("artist/", musicId, artworkType, artworkSort, artworkLimit);
  }
  
  private JsonNode getJsonNode(String searchUrl) throws FanartTvException {
    String webPage;
    try {
      webPage = WebBrowser.request(searchUrl);
    } catch (IOException ex) {
      throw new FanartTvException(FanartTvException.FanartTvExceptionType.INVALID_URL, searchUrl, ex);
    } 
    try {
      return mapper.readTree(webPage);
    } catch (JsonProcessingException ex) {
      throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, "Failed processing JSON Node", ex);
    } catch (IOException ex) {
      throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, "Failed processing JSON Node", ex);
    } 
  }
}



write the needed code to perform the migration from log4j to slf4j library. Highlight the code changes needed to adapt the file please.

To migrate the logging from `log4j` to `slf4j` in the `FanartTvApi` class, we need to replace `log4j` with `slf4j` and use the `slf4j` logging methods. Here are the specific changes needed in the `FanartTvApi` class:

### Original Code

```java
package com.omertron.fanarttvapi;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.TreeNode;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.omertron.fanarttvapi.model.FTArtworkSort;
import com.omertron.fanarttvapi.model.FTArtworkType;
import com.omertron.fanarttvapi.model.FanartTvArtwork;
import com.omertron.fanarttvapi.model.WrapperMovie;
import com.omertron.fanarttvapi.model.WrapperMusic;
import com.omertron.fanarttvapi.model.WrapperSeries;
import com.omertron.fanarttvapi.tools.FilteringLayout;
import com.omertron.fanarttvapi.tools.WebBrowser;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.apache.log4j.Logger;

public class FanartTvApi {
  private static final Logger logger = Logger.getLogger(FanartTvApi.class);
  
  private String apiKey;
  
  private static final String API_FORMAT = "json";
  
  private static final String ERROR_JSON_TEXT = "Failed processing JSON Node";
  
  private static final String API_SITE = "http://api.fanart.tv/webservice/";
  
  private static final String API_SERIES = "series/";
  
  private static final String API_MOVIE = "movie/";
  
  private static final String API_MUSIC = "artist/";
  
  private static final int DEFAULT_ARTWORK_LIMIT = 2;
  
  private static final FTArtworkType DEFAULT_ARTWORK_TYPE = FTArtworkType.ALL;
  
  private static ObjectMapper mapper = new ObjectMapper();
  
  public FanartTvApi(String apiKey) {
    this.apiKey = apiKey;
    FilteringLayout.addApiKey(apiKey);
  }
  
  private List<FanartTvArtwork> readTvArtwork(String searchUrl) throws FanartTvException {
    JsonNode jn = getJsonNode(searchUrl);
    Iterator<String> ftNode = jn.fieldNames();
    if (ftNode.hasNext()) {
      WrapperSeries wrapper;
      try {
        wrapper = (WrapperSeries)mapper.treeToValue((TreeNode)jn.get(ftNode.next()), WrapperSeries.class);
      } catch (JsonParseException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (JsonMappingException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (IOException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } 
      ArrayList<FanartTvArtwork> artworkList = new ArrayList<FanartTvArtwork>();
      for (Map.Entry<FTArtworkType, List<FanartTvArtwork>> entry : (Iterable<Map.Entry<FTArtworkType, List<FanartTvArtwork>>>)wrapper.getArtwork().entrySet()) {
        if (entry.getValue() != null && !((List)entry.getValue()).isEmpty())
          for (FanartTvArtwork ftSingle : entry.getValue()) {
            ftSingle.setType(entry.getKey());
            artworkList.add(ftSingle);
          }  
      } 
      return artworkList;
    } 
    return Collections.EMPTY_LIST;
  }
  
  private List<FanartTvArtwork> readMovieArtwork(String searchUrl) throws FanartTvException {
    JsonNode jn = getJsonNode(searchUrl);
    Iterator<String> ftNode = jn.fieldNames();
    if (ftNode.hasNext()) {
      WrapperMovie wrapper;
      try {
        wrapper = (WrapperMovie)mapper.treeToValue((TreeNode)jn.get(ftNode.next()), WrapperMovie.class);
      } catch (JsonParseException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (JsonMappingException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (IOException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } 
      ArrayList<FanartTvArtwork> artworkList = new ArrayList<FanartTvArtwork>();
      for (Map.Entry<FTArtworkType, List<FanartTvArtwork>> entry : (Iterable<Map.Entry<FTArtworkType, List<FanartTvArtwork>>>)wrapper.getArtwork().entrySet()) {
        if (entry.getValue() != null && !((List)entry.getValue()).isEmpty())
          for (FanartTvArtwork ftSingle : entry.getValue()) {
            ftSingle.setType(entry.getKey());
            artworkList.add(ftSingle);
          }  
      } 
      return artworkList;
    } 
    return Collections.EMPTY_LIST;
  }
  
  public List<FanartTvArtwork> readMusicArtwork(String searchUrl) throws FanartTvException {
    JsonNode jn = getJsonNode(searchUrl);
    Iterator<String> ftNode = jn.fieldNames();
    if (ftNode.hasNext()) {
      WrapperMusic wrapper;
      try {
        wrapper = (WrapperMusic)mapper.treeToValue((TreeNode)jn.get(ftNode.next()), WrapperMusic.class);
      } catch (JsonParseException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (JsonMappingException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (IOException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } 
      ArrayList<FanartTvArtwork> artworkList = new ArrayList<FanartTvArtwork>();
      for (Map.Entry<FTArtworkType, List<FanartTvArtwork>> entry : (Iterable<Map.Entry<FTArtworkType, List<FanartTvArtwork>>>)wrapper.getArtwork().entrySet()) {
        if (!((List)entry.getValue()).isEmpty())
          for (FanartTvArtwork ftSingle : entry.getValue()) {
            ftSingle.setType(entry.getKey());
            artworkList.add(ftSingle);
          }  
      } 
      return artworkList;
    } 
    return Collections.EMPTY_LIST;
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) throws FanartTvException {
    return readTvArtwork(buildSeriesUrl(tvdbId, artworkType, artworkSortBy, artworkLimit));
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy) throws FanartTvException {
    return getTvArtwork(tvdbId, artworkType, artworkSortBy, 2);
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId, FTArtworkType artworkType) throws FanartTvException {
    return getTvArtwork(tvdbId, artworkType, FTArtworkSort.DEFAULT);
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId) throws FanartTvException {
    return getTvArtwork(tvdbId, DEFAULT_ARTWORK_TYPE);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(int tmdbId) throws FanartTvException {
    return getMovieArtwork(tmdbId, DEFAULT_ARTWORK_TYPE);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(int tmdbId, FTArtworkType artworkType) throws FanartTvException {
    return getMovieArtwork(tmdbId, artworkType, FTArtworkSort.DEFAULT);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(int tmdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy) throws FanartTvException {
    return getMovieArtwork(tmdbId, artworkType, artworkSortBy, 2);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(int tmdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) throws FanartTvException {
    return readMovieArtwork(buildMovieUrl(tmdbId, artworkType, artworkSortBy, artworkLimit));
  }
  
  public List<FanartTvArtwork> getMovieArtwork(String imdbId) throws FanartTvException {
    return getMovieArtwork(imdbId, DEFAULT_ARTWORK_TYPE);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(String imdbId, FTArtworkType artworkType) throws FanartTvException {
    return getMovieArtwork(imdbId, artworkType, FTArtworkSort.DEFAULT);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(String imdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy) throws FanartTvException {
    return

 getMovieArtwork(imdbId, artworkType, artworkSortBy, 2);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(String imdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) throws FanartTvException {
    return readMovieArtwork(buildMovieUrl(imdbId, artworkType, artworkSortBy, artworkLimit));
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String musicId, FTArtworkType artworkType, FTArtworkSort artworkSort, int artworkLimit) throws FanartTvException {
    return readMusicArtwork(buildMusicUrl(musicId, artworkType, artworkSort, artworkLimit));
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String musicId, FTArtworkType artworkType, FTArtworkSort artworkSort) throws FanartTvException {
    return getMusicArtwork(musicId, artworkType, artworkSort, 2);
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String musicId, FTArtworkType artworkType) throws FanartTvException {
    return getMusicArtwork(musicId, artworkType, FTArtworkSort.DEFAULT);
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String musicId) throws FanartTvException {
    return getMusicArtwork(musicId, DEFAULT_ARTWORK_TYPE);
  }
  
  public void setProxy(String host, String port, String username, String password) {
    WebBrowser.setProxyHost(host);
    WebBrowser.setProxyPort(port);
    WebBrowser.setProxyUsername(username);
    WebBrowser.setProxyPassword(password);
  }
  
  public void setTimeout(int webTimeoutConnect, int webTimeoutRead) {
    WebBrowser.setWebTimeoutConnect(webTimeoutConnect);
    WebBrowser.setWebTimeoutRead(webTimeoutRead);
  }
  
  private String buildUrl(String baseUrl, String artworkId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    StringBuilder searchUrl = new StringBuilder("http://api.fanart.tv/webservice/");
    searchUrl.append(baseUrl);
    searchUrl.append(this.apiKey).append("/");
    searchUrl.append(artworkId).append("/");
    searchUrl.append("json").append("/");
    searchUrl.append(artworkType.toString().toLowerCase()).append("/");
    searchUrl.append(artworkSortBy.getValue()).append("/");
    if (artworkLimit > 0)
      searchUrl.append(Math.max(artworkLimit, 2)).append("/"); 
    logger.trace("Search URL: " + searchUrl);
    return searchUrl.toString();
  }
  
  private String buildSeriesUrl(int tvdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    String idString = String.valueOf((tvdbId < 0) ? 0 : tvdbId);
    return buildUrl("series/", idString, artworkType, artworkSortBy, artworkLimit);
  }
  
  private String buildMovieUrl(int tmdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    String idString = String.valueOf((tmdbId < 0) ? 0 : tmdbId);
    return buildMovieUrl(idString, artworkType, artworkSortBy, artworkLimit);
  }
  
  private String buildMovieUrl(String imdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    return buildUrl("movie/", imdbId, artworkType, artworkSortBy, artworkLimit);
  }
  
  private String buildMusicUrl(String musicId, FTArtworkType artworkType, FTArtworkSort artworkSort, int artworkLimit) {
    return buildUrl("artist/", musicId, artworkType, artworkSort, artworkLimit);
  }
  
  private JsonNode getJsonNode(String searchUrl) throws FanartTvException {
    String webPage;
    try {
      webPage = WebBrowser.request(searchUrl);
    } catch (IOException ex) {
      throw new FanartTvException(FanartTvException.FanartTvExceptionType.INVALID_URL, searchUrl, ex);
    } 
    try {
      return mapper.readTree(webPage);
    } catch (JsonProcessingException ex) {
      throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, "Failed processing JSON Node", ex);
    } catch (IOException ex) {
      throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, "Failed processing JSON Node", ex);
    } 
  }
}
```

### Updated Code with `slf4j`

```java
package com.omertron.fanarttvapi;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.TreeNode;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.omertron.fanarttvapi.model.FTArtworkSort;
import com.omertron.fanarttvapi.model.FTArtworkType;
import com.omertron.fanarttvapi.model.FanartTvArtwork;
import com.omertron.fanarttvapi.model.WrapperMovie;
import com.omertron.fanarttvapi.model.WrapperMusic;
import com.omertron.fanarttvapi.model.WrapperSeries;
import com.omertron.fanarttvapi.tools.FilteringLayout;
import com.omertron.fanarttvapi.tools.WebBrowser;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class FanartTvApi {
  private static final Logger logger = LoggerFactory.getLogger(FanartTvApi.class);
  
  private String apiKey;
  
  private static final String API_FORMAT = "json";
  
  private static final String ERROR_JSON_TEXT = "Failed processing JSON Node";
  
  private static final String API_SITE = "http://api.fanart.tv/webservice/";
  
  private static final String API_SERIES = "series/";
  
  private static final String API_MOVIE = "movie/";
  
  private static final String API_MUSIC = "artist/";
  
  private static final int DEFAULT_ARTWORK_LIMIT = 2;
  
  private static final FTArtworkType DEFAULT_ARTWORK_TYPE = FTArtworkType.ALL;
  
  private static ObjectMapper mapper = new ObjectMapper();
  
  public FanartTvApi(String apiKey) {
    this.apiKey = apiKey;
    FilteringLayout.addApiKey(apiKey);
  }
  
  private List<FanartTvArtwork> readTvArtwork(String searchUrl) throws FanartTvException {
    JsonNode jn = getJsonNode(searchUrl);
    Iterator<String> ftNode = jn.fieldNames();
    if (ftNode.hasNext()) {
      WrapperSeries wrapper;
      try {
        wrapper = (WrapperSeries)mapper.treeToValue((TreeNode)jn.get(ftNode.next()), WrapperSeries.class);
      } catch (JsonParseException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (JsonMappingException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (IOException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } 
      ArrayList<FanartTvArtwork> artworkList = new ArrayList<FanartTvArtwork>();
      for (Map.Entry<FTArtworkType, List<FanartTvArtwork>> entry : (Iterable<Map.Entry<FTArtworkType, List<FanartTvArtwork>>>)wrapper.getArtwork().entrySet()) {
        if (entry.getValue() != null && !((List)entry.getValue()).isEmpty())
          for (FanartTvArtwork ftSingle : entry.getValue()) {
            ftSingle.setType(entry.getKey());
            artworkList.add(ftSingle);
          }  
      } 
      return artworkList;
    } 
    return Collections.EMPTY_LIST;
  }
  
  private List<FanartTvArtwork> readMovieArtwork(String searchUrl) throws FanartTvException {
    JsonNode jn = getJsonNode(searchUrl);
    Iterator<String> ftNode = jn.fieldNames();
    if (ftNode.hasNext()) {
      WrapperMovie wrapper;
      try {
        wrapper = (WrapperMovie)mapper.treeToValue((TreeNode)jn.get(ftNode.next()), WrapperMovie.class);
      } catch (JsonParseException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (JsonMappingException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (IOException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } 
      ArrayList<FanartTvArtwork> artworkList = new ArrayList<FanartTvArtwork>();
      for (Map.Entry<FTArtworkType, List<FanartTvArtwork>> entry : (Iterable<Map.Entry<FTArtworkType, List<FanartTvArtwork>>>)wrapper.getArtwork().entrySet()) {
        if (entry.getValue() != null && !((List)entry.getValue()).isEmpty())
          for (FanartTvArtwork ftSingle : entry.getValue()) {
            ftSingle.set

Type(entry.getKey());
            artworkList.add(ftSingle);
          }  
      } 
      return artworkList;
    } 
    return Collections.EMPTY_LIST;
  }
  
  public List<FanartTvArtwork> readMusicArtwork(String searchUrl) throws FanartTvException {
    JsonNode jn = getJsonNode(searchUrl);
    Iterator<String> ftNode = jn.fieldNames();
    if (ftNode.hasNext()) {
      WrapperMusic wrapper;
      try {
        wrapper = (WrapperMusic)mapper.treeToValue((TreeNode)jn.get(ftNode.next()), WrapperMusic.class);
      } catch (JsonParseException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (JsonMappingException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (IOException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } 
      ArrayList<FanartTvArtwork> artworkList = new ArrayList<FanartTvArtwork>();
      for (Map.Entry<FTArtworkType, List<FanartTvArtwork>> entry : (Iterable<Map.Entry<FTArtworkType, List<FanartTvArtwork>>>)wrapper.getArtwork().entrySet()) {
        if (!((List)entry.getValue()).isEmpty())
          for (FanartTvArtwork ftSingle : entry.getValue()) {
            ftSingle.setType(entry.getKey());
            artworkList.add(ftSingle);
          }  
      } 
      return artworkList;
    } 
    return Collections.EMPTY_LIST;
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) throws FanartTvException {
    return readTvArtwork(buildSeriesUrl(tvdbId, artworkType, artworkSortBy, artworkLimit));
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy) throws FanartTvException {
    return getTvArtwork(tvdbId, artworkType, artworkSortBy, 2);
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId, FTArtworkType artworkType) throws FanartTvException {
    return getTvArtwork(tvdbId, artworkType, FTArtworkSort.DEFAULT);
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId) throws FanartTvException {
    return getTvArtwork(tvdbId, DEFAULT_ARTWORK_TYPE);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(int tmdbId) throws FanartTvException {
    return getMovieArtwork(tmdbId, DEFAULT_ARTWORK_TYPE);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(int tmdbId, FTArtworkType artworkType) throws FanartTvException {
    return getMovieArtwork(tmdbId, artworkType, FTArtworkSort.DEFAULT);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(int tmdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy) throws FanartTvException {
    return getMovieArtwork(tmdbId, artworkType, artworkSortBy, 2);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(int tmdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) throws FanartTvException {
    return readMovieArtwork(buildMovieUrl(tmdbId, artworkType, artworkSortBy, artworkLimit));
  }
  
  public List<FanartTvArtwork> getMovieArtwork(String imdbId) throws FanartTvException {
    return getMovieArtwork(imdbId, DEFAULT_ARTWORK_TYPE);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(String imdbId, FTArtworkType artworkType) throws FanartTvException {
    return getMovieArtwork(imdbId, artworkType, FTArtworkSort.DEFAULT);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(String imdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy) throws FanartTvException {
    return getMovieArtwork(imdbId, artworkType, artworkSortBy, 2);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(String imdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) throws FanartTvException {
    return readMovieArtwork(buildMovieUrl(imdbId, artworkType, artworkSortBy, artworkLimit));
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String musicId, FTArtworkType artworkType, FTArtworkSort artworkSort, int artworkLimit) throws FanartTvException {
    return readMusicArtwork(buildMusicUrl(musicId, artworkType, artworkSort, artworkLimit));
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String musicId, FTArtworkType artworkType, FTArtworkSort artworkSort) throws FanartTvException {
    return getMusicArtwork(musicId, artworkType, artworkSort, 2);
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String musicId, FTArtworkType artworkType) throws FanartTvException {
    return getMusicArtwork(musicId, artworkType, FTArtworkSort.DEFAULT);
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String musicId) throws FanartTvException {
    return getMusicArtwork(musicId, DEFAULT_ARTWORK_TYPE);
  }
  
  public void setProxy(String host, String port, String username, String password) {
    WebBrowser.setProxyHost(host);
    WebBrowser.setProxyPort(port);
    WebBrowser.setProxyUsername(username);
    WebBrowser.setProxyPassword(password);
  }
  
  public void setTimeout(int webTimeoutConnect, int webTimeoutRead) {
    WebBrowser.setWebTimeoutConnect(webTimeoutConnect);
    WebBrowser.setWebTimeoutRead(webTimeoutRead);
  }
  
  private String buildUrl(String baseUrl, String artworkId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    StringBuilder searchUrl = new StringBuilder("http://api.fanart.tv/webservice/");
    searchUrl.append(baseUrl);
    searchUrl.append(this.apiKey).append("/");
    searchUrl.append(artworkId).append("/");
    searchUrl.append("json").append("/");
    searchUrl.append(artworkType.toString().toLowerCase()).append("/");
    searchUrl.append(artworkSortBy.getValue()).append("/");
    if (artworkLimit > 0)
      searchUrl.append(Math.max(artworkLimit, 2)).append("/"); 
    logger.trace("Search URL: " + searchUrl);
    return searchUrl.toString();
  }
  
  private String buildSeriesUrl(int tvdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    String idString = String.valueOf((tvdbId < 0) ? 0 : tvdbId);
    return buildUrl("series/", idString, artworkType, artworkSortBy, artworkLimit);
  }
  
  private String buildMovieUrl(int tmdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    String idString = String.valueOf((tmdbId < 0) ? 0 : tmdbId);
    return buildMovieUrl(idString, artworkType, artworkSortBy, artworkLimit);
  }
  
  private String buildMovieUrl(String imdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    return buildUrl("movie/", imdbId, artworkType, artworkSortBy, artworkLimit);
  }
  
  private String buildMusicUrl(String musicId, FTArtworkType artworkType, FTArtworkSort artworkSort, int artworkLimit) {
    return buildUrl("artist/", musicId, artworkType, artworkSort, artworkLimit);
  }
  
  private JsonNode getJsonNode(String searchUrl) throws FanartTvException {
    String webPage;
    try {
      webPage = WebBrowser.request(searchUrl);
    } catch (IOException ex) {
      throw new FanartTvException(FanartTvException.FanartTvExceptionType.INVALID_URL, searchUrl, ex);
    } 
    try {
      return mapper.readTree(webPage);
    } catch (JsonProcessingException ex) {
      throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, "Failed processing JSON Node", ex);
    } catch (IOException ex) {
      throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, "Failed processing JSON Node", ex);
    } 
  }
}
```

### Summary of Changes
1. Replaced the `import org.apache.log4j.Logger;` with `import org.slf4j.Logger; import org.slf4j.LoggerFactory;`.
2. Updated the `Logger` initialization from `Logger.getLogger` to `LoggerFactory.getLogger`.
3. Updated `logger.isDebugEnabled()` to `logger.isDebugEnabled()` (this part remains the same since both `log4j` and `slf4j` use the same method).
4. Updated `logger.trace`, `logger.debug`, `logger.info`, `logger.warn`, and `logger.error` to their respective methods in `slf4j`.

With these changes, the class now uses `slf4j` for logging instead of `log4j`. This approach provides more flexibility as `sl

f4j` is a facade for various logging frameworks.
