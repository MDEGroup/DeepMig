You are a Java code assistant. Given this Java class: 

package com.omertron.fanarttvapi;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.TreeNode;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.omertron.fanarttvapi.model.FTArtworkSort;
import com.omertron.fanarttvapi.model.FTArtworkType;
import com.omertron.fanarttvapi.model.FanartTvArtwork;
import com.omertron.fanarttvapi.model.WrapperMovie;
import com.omertron.fanarttvapi.model.WrapperMusic;
import com.omertron.fanarttvapi.model.WrapperSeries;
import com.omertron.fanarttvapi.tools.FilteringLayout;
import com.omertron.fanarttvapi.tools.WebBrowser;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.apache.log4j.Logger;

public class FanartTvApi {
  private static final Logger logger = Logger.getLogger(FanartTvApi.class);
  
  private String apiKey;
  
  private static final String API_FORMAT = "json";
  
  private static final String ERROR_JSON_TEXT = "Failed processing JSON Node";
  
  private static final String API_SITE = "http://api.fanart.tv/webservice/";
  
  private static final String API_SERIES = "series/";
  
  private static final String API_MOVIE = "movie/";
  
  private static final String API_MUSIC = "artist/";
  
  private static final int DEFAULT_ARTWORK_LIMIT = 2;
  
  private static final FTArtworkType DEFAULT_ARTWORK_TYPE = FTArtworkType.ALL;
  
  private static ObjectMapper mapper = new ObjectMapper();
  
  public FanartTvApi(String apiKey) {
    this.apiKey = apiKey;
    FilteringLayout.addApiKey(apiKey);
  }
  
  private List<FanartTvArtwork> readTvArtwork(String searchUrl) throws FanartTvException {
    JsonNode jn = getJsonNode(searchUrl);
    Iterator<String> ftNode = jn.fieldNames();
    if (ftNode.hasNext()) {
      WrapperSeries wrapper;
      try {
        wrapper = (WrapperSeries)mapper.treeToValue((TreeNode)jn.get(ftNode.next()), WrapperSeries.class);
      } catch (JsonParseException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (JsonMappingException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (IOException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } 
      ArrayList<FanartTvArtwork> artworkList = new ArrayList<FanartTvArtwork>();
      for (Map.Entry<FTArtworkType, List<FanartTvArtwork>> entry : (Iterable<Map.Entry<FTArtworkType, List<FanartTvArtwork>>>)wrapper.getArtwork().entrySet()) {
        if (entry.getValue() != null && !((List)entry.getValue()).isEmpty())
          for (FanartTvArtwork ftSingle : entry.getValue()) {
            ftSingle.setType(entry.getKey());
            artworkList.add(ftSingle);
          }  
      } 
      return artworkList;
    } 
    return Collections.EMPTY_LIST;
  }
  
  private List<FanartTvArtwork> readMovieArtwork(String searchUrl) throws FanartTvException {
    JsonNode jn = getJsonNode(searchUrl);
    Iterator<String> ftNode = jn.fieldNames();
    if (ftNode.hasNext()) {
      WrapperMovie wrapper;
      try {
        wrapper = (WrapperMovie)mapper.treeToValue((TreeNode)jn.get(ftNode.next()), WrapperMovie.class);
      } catch (JsonParseException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (JsonMappingException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (IOException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } 
      ArrayList<FanartTvArtwork> artworkList = new ArrayList<FanartTvArtwork>();
      for (Map.Entry<FTArtworkType, List<FanartTvArtwork>> entry : (Iterable<Map.Entry<FTArtworkType, List<FanartTvArtwork>>>)wrapper.getArtwork().entrySet()) {
        if (entry.getValue() != null && !((List)entry.getValue()).isEmpty())
          for (FanartTvArtwork ftSingle : entry.getValue()) {
            ftSingle.setType(entry.getKey());
            artworkList.add(ftSingle);
          }  
      } 
      return artworkList;
    } 
    return Collections.EMPTY_LIST;
  }
  
  public List<FanartTvArtwork> readMusicArtwork(String searchUrl) throws FanartTvException {
    JsonNode jn = getJsonNode(searchUrl);
    Iterator<String> ftNode = jn.fieldNames();
    if (ftNode.hasNext()) {
      WrapperMusic wrapper;
      try {
        wrapper = (WrapperMusic)mapper.treeToValue((TreeNode)jn.get(ftNode.next()), WrapperMusic.class);
      } catch (JsonParseException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (JsonMappingException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (IOException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } 
      ArrayList<FanartTvArtwork> artworkList = new ArrayList<FanartTvArtwork>();
      for (Map.Entry<FTArtworkType, List<FanartTvArtwork>> entry : (Iterable<Map.Entry<FTArtworkType, List<FanartTvArtwork>>>)wrapper.getArtwork().entrySet()) {
        if (!((List)entry.getValue()).isEmpty())
          for (FanartTvArtwork ftSingle : entry.getValue()) {
            ftSingle.setType(entry.getKey());
            artworkList.add(ftSingle);
          }  
      } 
      return artworkList;
    } 
    return Collections.EMPTY_LIST;
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) throws FanartTvException {
    return readTvArtwork(buildSeriesUrl(tvdbId, artworkType, artworkSortBy, artworkLimit));
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy) throws FanartTvException {
    return getTvArtwork(tvdbId, artworkType, artworkSortBy, 2);
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId, FTArtworkType artworkType) throws FanartTvException {
    return getTvArtwork(tvdbId, artworkType, FTArtworkSort.DEFAULT);
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId) throws FanartTvException {
    return getTvArtwork(tvdbId, DEFAULT_ARTWORK_TYPE);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(int tmdbId) throws FanartTvException {
    return getMovieArtwork(tmdbId, DEFAULT_ARTWORK_TYPE);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(int tmdbId, FTArtworkType artworkType) throws FanartTvException {
    return getMovieArtwork(tmdbId, artworkType, FTArtworkSort.DEFAULT);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(int tmdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy) throws FanartTvException {
    return getMovieArtwork(tmdbId, artworkType, artworkSortBy, 2);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(int tmdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) throws FanartTvException {
    return readMovieArtwork(buildMovieUrl(tmdbId, artworkType, artworkSortBy, artworkLimit));
  }
  
  public List<FanartTvArtwork> getMovieArtwork(String imdbId) throws FanartTvException {
    return getMovieArtwork(imdbId, DEFAULT_ARTWORK_TYPE);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(String imdbId, FTArtworkType artworkType) throws FanartTvException {
    return getMovieArtwork(imdbId, artworkType, FTArtworkSort.DEFAULT);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(String imdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy) throws FanartTvException {
    return getMovieArtwork(imdbId, artworkType, artworkSortBy, 2);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(String imdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) throws FanartTvException {
    return readMovieArtwork(buildMovieUrl(imdbId, artworkType, artworkSortBy, artworkLimit));
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String musicId, FTArtworkType artworkType, FTArtworkSort artworkSort, int artworkLimit) throws FanartTvException {
    return readMusicArtwork(buildMusicUrl(musicId, artworkType, artworkSort, artworkLimit));
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String musicId, FTArtworkType artworkType, FTArtworkSort artworkSort) throws FanartTvException {
    return getMusicArtwork(musicId, artworkType, artworkSort, 2);
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String musicId, FTArtworkType artworkType) throws FanartTvException {
    return getMusicArtwork(musicId, artworkType, FTArtworkSort.DEFAULT);
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String musicId) throws FanartTvException {
    return getMusicArtwork(musicId, DEFAULT_ARTWORK_TYPE);
  }
  
  public void setProxy(String host, String port, String username, String password) {
    WebBrowser.setProxyHost(host);
    WebBrowser.setProxyPort(port);
    WebBrowser.setProxyUsername(username);
    WebBrowser.setProxyPassword(password);
  }
  
  public void setTimeout(int webTimeoutConnect, int webTimeoutRead) {
    WebBrowser.setWebTimeoutConnect(webTimeoutConnect);
    WebBrowser.setWebTimeoutRead(webTimeoutRead);
  }
  
  private String buildUrl(String baseUrl, String artworkId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    StringBuilder searchUrl = new StringBuilder("http://api.fanart.tv/webservice/");
    searchUrl.append(baseUrl);
    searchUrl.append(this.apiKey).append("/");
    searchUrl.append(artworkId).append("/");
    searchUrl.append("json").append("/");
    searchUrl.append(artworkType.toString().toLowerCase()).append("/");
    searchUrl.append(artworkSortBy.getValue()).append("/");
    if (artworkLimit > 0)
      searchUrl.append(Math.max(artworkLimit, 2)).append("/"); 
    logger.trace("Search URL: " + searchUrl);
    return searchUrl.toString();
  }
  
  private String buildSeriesUrl(int tvdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    String idString = String.valueOf((tvdbId < 0) ? 0 : tvdbId);
    return buildUrl("series/", idString, artworkType, artworkSortBy, artworkLimit);
  }
  
  private String buildMovieUrl(int tmdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    String idString = String.valueOf((tmdbId < 0) ? 0 : tmdbId);
    return buildMovieUrl(idString, artworkType, artworkSortBy, artworkLimit);
  }
  
  private String buildMovieUrl(String imdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    return buildUrl("movie/", imdbId, artworkType, artworkSortBy, artworkLimit);
  }
  
  private String buildMusicUrl(String musicId, FTArtworkType artworkType, FTArtworkSort artworkSort, int artworkLimit) {
    return buildUrl("artist/", musicId, artworkType, artworkSort, artworkLimit);
  }
  
  private JsonNode getJsonNode(String searchUrl) throws FanartTvException {
    String webPage;
    try {
      webPage = WebBrowser.request(searchUrl);
    } catch (IOException ex) {
      throw new FanartTvException(FanartTvException.FanartTvExceptionType.INVALID_URL, searchUrl, ex);
    } 
    try {
      return mapper.readTree(webPage);
    } catch (JsonProcessingException ex) {
      throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, "Failed processing JSON Node", ex);
    } catch (IOException ex) {
      throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, "Failed processing JSON Node", ex);
    } 
  }
}


write the needed code to perform the migration from log4j to slf4j library. Highlight the code changes needed to adapt the file please.

To migrate from log4j to slf4j in the `FanartTvApi` class, you need to replace the log4j `Logger` with the slf4j `Logger`. Here are the changes needed to adapt the provided class:

### Original Code with log4j
```java
package com.omertron.fanarttvapi;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.TreeNode;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.omertron.fanarttvapi.model.FTArtworkSort;
import com.omertron.fanarttvapi.model.FTArtworkType;
import com.omertron.fanarttvapi.model.FanartTvArtwork;
import com.omertron.fanarttvapi.model.WrapperMovie;
import com.omertron.fanarttvapi.model.WrapperMusic;
import com.omertron.fanarttvapi.model.WrapperSeries;
import com.omertron.fanarttvapi.tools.FilteringLayout;
import com.omertron.fanarttvapi.tools.WebBrowser;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.apache.log4j.Logger;

public class FanartTvApi {
  private static final Logger logger = Logger.getLogger(FanartTvApi.class);
  
  private String apiKey;
  
  private static final String API_FORMAT = "json";
  
  private static final String ERROR_JSON_TEXT = "Failed processing JSON Node";
  
  private static final String API_SITE = "http://api.fanart.tv/webservice/";
  
  private static final String API_SERIES = "series/";
  
  private static final String API_MOVIE = "movie/";
  
  private static final String API_MUSIC = "artist/";
  
  private static final int DEFAULT_ARTWORK_LIMIT = 2;
  
  private static final FTArtworkType DEFAULT_ARTWORK_TYPE = FTArtworkType.ALL;
  
  private static ObjectMapper mapper = new ObjectMapper();
  
  public FanartTvApi(String apiKey) {
    this.apiKey = apiKey;
    FilteringLayout.addApiKey(apiKey);
  }
  
  private List<FanartTvArtwork> readTvArtwork(String searchUrl) throws FanartTvException {
    JsonNode jn = getJsonNode(searchUrl);
    Iterator<String> ftNode = jn.fieldNames();
    if (ftNode.hasNext()) {
      WrapperSeries wrapper;
      try {
        wrapper = (WrapperSeries)mapper.treeToValue((TreeNode)jn.get(ftNode.next()), WrapperSeries.class);
      } catch (JsonParseException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (JsonMappingException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (IOException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } 
      ArrayList<FanartTvArtwork> artworkList = new ArrayList<FanartTvArtwork>();
      for (Map.Entry<FTArtworkType, List<FanartTvArtwork>> entry : (Iterable<Map.Entry<FTArtworkType, List<FanartTvArtwork>>>)wrapper.getArtwork().entrySet()) {
        if (entry.getValue() != null && !((List)entry.getValue()).isEmpty())
          for (FanartTvArtwork ftSingle : entry.getValue()) {
            ftSingle.setType(entry.getKey());
            artworkList.add(ftSingle);
          }  
      } 
      return artworkList;
    } 
    return Collections.EMPTY_LIST;
  }
  
  private List<FanartTvArtwork> readMovieArtwork(String searchUrl) throws FanartTvException {
    JsonNode jn = getJsonNode(searchUrl);
    Iterator<String> ftNode = jn.fieldNames();
    if (ftNode.hasNext()) {
      WrapperMovie wrapper;
      try {
        wrapper = (WrapperMovie)mapper.treeToValue((TreeNode)jn.get(ftNode.next()), WrapperMovie.class);
      } catch (JsonParseException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (JsonMappingException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (IOException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } 
      ArrayList<FanartTvArtwork> artworkList = new ArrayList<FanartTvArtwork>();
      for (Map.Entry<FTArtworkType, List<FanartTvArtwork>> entry : (Iterable<Map.Entry<FTArtworkType, List<FanartTvArtwork>>>)wrapper.getArtwork().entrySet()) {
        if (entry.getValue() != null && !((List)entry.getValue()).isEmpty())
          for (FanartTvArtwork ftSingle : entry.getValue()) {
            ftSingle.setType(entry.getKey());
            artworkList.add(ftSingle);
          }  
      } 
      return artworkList;
    } 
    return Collections.EMPTY_LIST;
  }
  
  public List<FanartTvArtwork> readMusicArtwork(String searchUrl) throws FanartTvException {
    JsonNode jn = getJsonNode(searchUrl);
    Iterator<String> ftNode = jn.fieldNames();
    if (ftNode.hasNext()) {
      WrapperMusic wrapper;
      try {
        wrapper = (WrapperMusic)mapper.treeToValue((TreeNode)jn.get(ftNode.next()), WrapperMusic.class);
      } catch (JsonParseException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (JsonMappingException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (IOException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } 
      ArrayList<FanartTvArtwork> artworkList = new ArrayList<FanartTvArtwork>();
      for (Map.Entry<FTArtworkType, List<FanartTvArtwork>> entry : (Iterable<Map.Entry<FTArtworkType, List<FanartTvArtwork>>>)wrapper.getArtwork().entrySet()) {
        if (!((List)entry.getValue()).isEmpty())
          for (FanartTvArtwork ftSingle : entry.getValue()) {
            ftSingle.setType(entry.getKey());
            artworkList.add(ftSingle);
          }  
      } 
      return artworkList;
    } 
    return Collections.EMPTY_LIST;
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) throws FanartTvException {
    return readTvArtwork(buildSeriesUrl(tvdbId, artworkType, artworkSortBy, artworkLimit));
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy) throws FanartTvException {
    return getTvArtwork(tvdbId, artworkType, artworkSortBy, 2);
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId, FTArtworkType artworkType) throws FanartTvException {
    return getTvArtwork(tvdbId, artworkType, FTArtworkSort.DEFAULT);
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId) throws FanartTvException {
    return getTvArtwork(tvdbId, DEFAULT_ARTWORK_TYPE);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(int tmdbId) throws FanartTvException {
    return getMovieArtwork(tmdbId, DEFAULT_ARTWORK_TYPE);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(int tmdbId, FTArtworkType artworkType) throws FanartTvException {
    return getMovieArtwork(tmdbId, artworkType, FTArtworkSort.DEFAULT);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(int tmdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy) throws FanartTvException {
    return getMovieArtwork(tmdbId, artworkType, artworkSortBy, 2);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(int tmdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) throws FanartTvException {
    return readMovieArtwork(buildMovieUrl(tmdbId, artworkType, artworkSortBy, artworkLimit));
  }
  
  public List<FanartTvArtwork> getMovieArtwork(String imdbId) throws FanartTvException {
    return getMovieArtwork(imdbId, DEFAULT_ARTWORK_TYPE);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(String imdbId, FTArtworkType artworkType) throws FanartTvException {
    return getMovieArtwork(imdbId, artworkType, FTArtworkSort.DEFAULT);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(String imdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy) throws FanartTvException {
    return getMovieArtwork(imdbId, artworkType, artworkSortBy, 

2);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(String imdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) throws FanartTvException {
    return readMovieArtwork(buildMovieUrl(imdbId, artworkType, artworkSortBy, artworkLimit));
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String mbId) throws FanartTvException {
    return getMusicArtwork(mbId, DEFAULT_ARTWORK_TYPE);
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String mbId, FTArtworkType artworkType) throws FanartTvException {
    return getMusicArtwork(mbId, artworkType, FTArtworkSort.DEFAULT);
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String mbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy) throws FanartTvException {
    return getMusicArtwork(mbId, artworkType, artworkSortBy, 2);
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String mbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) throws FanartTvException {
    return readMusicArtwork(buildMusicUrl(mbId, artworkType, artworkSortBy, artworkLimit));
  }
  
  private String buildSeriesUrl(int tvdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    return String.format("http://api.fanart.tv/webservice/series/%s/%d/%s/%s/%d", this.apiKey, Integer.valueOf(tvdbId), artworkType.toString(), artworkSortBy.toString(), Integer.valueOf(artworkLimit));
  }
  
  private String buildMovieUrl(int tmdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    return String.format("http://api.fanart.tv/webservice/movie/%s/%d/%s/%s/%d", this.apiKey, Integer.valueOf(tmdbId), artworkType.toString(), artworkSortBy.toString(), Integer.valueOf(artworkLimit));
  }
  
  private String buildMovieUrl(String imdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    return String.format("http://api.fanart.tv/webservice/movie/%s/%s/%s/%s/%d", this.apiKey, imdbId, artworkType.toString(), artworkSortBy.toString(), Integer.valueOf(artworkLimit));
  }
  
  private String buildMusicUrl(String mbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    return String.format("http://api.fanart.tv/webservice/artist/%s/%s/%s/%s/%d", this.apiKey, mbId, artworkType.toString(), artworkSortBy.toString(), Integer.valueOf(artworkLimit));
  }
  
  private JsonNode getJsonNode(String searchUrl) throws FanartTvException {
    try {
      String webPage = WebBrowser.request(searchUrl);
      JsonNode rootNode = mapper.readTree(webPage);
      if (rootNode == null)
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.INVALID_JSON, "Invalid JSON response", null); 
      if (rootNode.has("error message"))
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.INVALID_JSON, rootNode.get("error message").asText(), null); 
      return rootNode;
    } catch (JsonProcessingException ex) {
      throw new FanartTvException(FanartTvException.FanartTvExceptionType.INVALID_JSON, "Failed to process JSON", ex);
    } catch (IOException ex) {
      throw new FanartTvException(FanartTvException.FanartTvExceptionType.HTTP_ERROR, "Failed to connect to Fanart.TV server", ex);
    } 
  }
}
```

### Refactored Code with slf4j
Replace all `org.apache.log4j.Logger` imports and usages with `org.slf4j.Logger` and `org.slf4j.LoggerFactory`.

Here's the updated code with `slf4j`:

```java
package com.omertron.fanarttvapi;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.TreeNode;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.omertron.fanarttvapi.model.FTArtworkSort;
import com.omertron.fanarttvapi.model.FTArtworkType;
import com.omertron.fanarttvapi.model.FanartTvArtwork;
import com.omertron.fanarttvapi.model.WrapperMovie;
import com.omertron.fanarttvapi.model.WrapperMusic;
import com.omertron.fanarttvapi.model.WrapperSeries;
import com.omertron.fanarttvapi.tools.FilteringLayout;
import com.omertron.fanarttvapi.tools.WebBrowser;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class FanartTvApi {
  private static final Logger logger = LoggerFactory.getLogger(FanartTvApi.class);
  
  private String apiKey;
  
  private static final String API_FORMAT = "json";
  
  private static final String ERROR_JSON_TEXT = "Failed processing JSON Node";
  
  private static final String API_SITE = "http://api.fanart.tv/webservice/";
  
  private static final String API_SERIES = "series/";
  
  private static final String API_MOVIE = "movie/";
  
  private static final String API_MUSIC = "artist/";
  
  private static final int DEFAULT_ARTWORK_LIMIT = 2;
  
  private static final FTArtworkType DEFAULT_ARTWORK_TYPE = FTArtworkType.ALL;
  
  private static ObjectMapper mapper = new ObjectMapper();
  
  public FanartTvApi(String apiKey) {
    this.apiKey = apiKey;
    FilteringLayout.addApiKey(apiKey);
  }
  
  private List<FanartTvArtwork> readTvArtwork(String searchUrl) throws FanartTvException {
    JsonNode jn = getJsonNode(searchUrl);
    Iterator<String> ftNode = jn.fieldNames();
    if (ftNode.hasNext()) {
      WrapperSeries wrapper;
      try {
        wrapper = mapper.treeToValue((TreeNode) jn.get(ftNode.next()), WrapperSeries.class);
      } catch (JsonParseException | JsonMappingException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (IOException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      }
      ArrayList<FanartTvArtwork> artworkList = new ArrayList<>();
      for (Map.Entry<FTArtworkType, List<FanartTvArtwork>> entry : wrapper.getArtwork().entrySet()) {
        if (entry.getValue() != null && !entry.getValue().isEmpty()) {
          for (FanartTvArtwork ftSingle : entry.getValue()) {
            ftSingle.setType(entry.getKey());
            artworkList.add(ftSingle);
          }
        }
      }
      return artworkList;
    }
    return Collections.emptyList();
  }
  
  private List<FanartTvArtwork> readMovieArtwork(String searchUrl) throws FanartTvException {
    JsonNode jn = getJsonNode(searchUrl);
    Iterator<String> ftNode = jn.fieldNames();
    if (ftNode.hasNext()) {
      WrapperMovie wrapper;
      try {
        wrapper = mapper.treeToValue((TreeNode) jn.get(ftNode.next()), WrapperMovie.class);
      } catch (JsonParseException | JsonMappingException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (IOException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      }
      ArrayList<FanartTvArtwork> artworkList = new ArrayList<>();
      for (Map.Entry<FTArtworkType, List<FanartTvArtwork>> entry : wrapper.getArtwork().entrySet()) {
        if (entry.getValue() != null && !entry.getValue().isEmpty()) {
          for (FanartTvArtwork ftSingle : entry.getValue()) {
            ftSingle.setType(entry.getKey());
            artworkList.add(ftSingle);
          }
        }
      }
      return artworkList;
    }
    return Collections.emptyList();
  }
  
  public List<FanartTvArtwork> readMusicArtwork(String searchUrl) throws FanartTvException {
    JsonNode jn = getJsonNode(searchUrl);
    Iterator<String> ftNode = jn.fieldNames();
    if (ftNode.hasNext()) {
      WrapperMusic wrapper;
      try {
        wrapper = mapper.treeToValue((TreeNode) jn.get(ftNode.next()), WrapperMusic.class);
      } catch (JsonParseException | JsonMappingException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      } catch (IOException ex) {
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.MAPPING_FAILED, null, ex);
      }
      ArrayList<FanartTvArtwork> artworkList = new ArrayList

<>();
      for (Map.Entry<FTArtworkType, List<FanartTvArtwork>> entry : wrapper.getArtwork().entrySet()) {
        if (entry.getValue() != null && !entry.getValue().isEmpty()) {
          for (FanartTvArtwork ftSingle : entry.getValue()) {
            ftSingle.setType(entry.getKey());
            artworkList.add(ftSingle);
          }
        }
      }
      return artworkList;
    }
    return Collections.emptyList();
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId) throws FanartTvException {
    return getTvArtwork(tvdbId, DEFAULT_ARTWORK_TYPE);
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId, FTArtworkType artworkType) throws FanartTvException {
    return getTvArtwork(tvdbId, artworkType, FTArtworkSort.DEFAULT);
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy) throws FanartTvException {
    return getTvArtwork(tvdbId, artworkType, artworkSortBy, 2);
  }
  
  public List<FanartTvArtwork> getTvArtwork(int tvdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) throws FanartTvException {
    return readTvArtwork(buildSeriesUrl(tvdbId, artworkType, artworkSortBy, artworkLimit));
  }
  
  public List<FanartTvArtwork> getMovieArtwork(int tmdbId) throws FanartTvException {
    return getMovieArtwork(tmdbId, DEFAULT_ARTWORK_TYPE);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(int tmdbId, FTArtworkType artworkType) throws FanartTvException {
    return getMovieArtwork(tmdbId, artworkType, FTArtworkSort.DEFAULT);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(int tmdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy) throws FanartTvException {
    return getMovieArtwork(tmdbId, artworkType, artworkSortBy, 2);
  }
  
  public List<FanartTvArtwork> getMovieArtwork(String imdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) throws FanartTvException {
    return readMovieArtwork(buildMovieUrl(imdbId, artworkType, artworkSortBy, artworkLimit));
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String mbId) throws FanartTvException {
    return getMusicArtwork(mbId, DEFAULT_ARTWORK_TYPE);
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String mbId, FTArtworkType artworkType) throws FanartTvException {
    return getMusicArtwork(mbId, artworkType, FTArtworkSort.DEFAULT);
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String mbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy) throws FanartTvException {
    return getMusicArtwork(mbId, artworkType, artworkSortBy, 2);
  }
  
  public List<FanartTvArtwork> getMusicArtwork(String mbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) throws FanartTvException {
    return readMusicArtwork(buildMusicUrl(mbId, artworkType, artworkSortBy, artworkLimit));
  }
  
  private String buildSeriesUrl(int tvdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    return String.format("http://api.fanart.tv/webservice/series/%s/%d/%s/%s/%d", this.apiKey, Integer.valueOf(tvdbId), artworkType.toString(), artworkSortBy.toString(), Integer.valueOf(artworkLimit));
  }
  
  private String buildMovieUrl(int tmdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    return String.format("http://api.fanart.tv/webservice/movie/%s/%d/%s/%s/%d", this.apiKey, Integer.valueOf(tmdbId), artworkType.toString(), artworkSortBy.toString(), Integer.valueOf(artworkLimit));
  }
  
  private String buildMovieUrl(String imdbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    return String.format("http://api.fanart.tv/webservice/movie/%s/%s/%s/%s/%d", this.apiKey, imdbId, artworkType.toString(), artworkSortBy.toString(), Integer.valueOf(artworkLimit));
  }
  
  private String buildMusicUrl(String mbId, FTArtworkType artworkType, FTArtworkSort artworkSortBy, int artworkLimit) {
    return String.format("http://api.fanart.tv/webservice/artist/%s/%s/%s/%s/%d", this.apiKey, mbId, artworkType.toString(), artworkSortBy.toString(), Integer.valueOf(artworkLimit));
  }
  
  private JsonNode getJsonNode(String searchUrl) throws FanartTvException {
    try {
      String webPage = WebBrowser.request(searchUrl);
      JsonNode rootNode = mapper.readTree(webPage);
      if (rootNode == null)
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.INVALID_JSON, "Invalid JSON response", null); 
      if (rootNode.has("error message"))
        throw new FanartTvException(FanartTvException.FanartTvExceptionType.INVALID_JSON, rootNode.get("error message").asText(), null); 
      return rootNode;
    } catch (JsonProcessingException ex) {
      throw new FanartTvException(FanartTvException.FanartTvExceptionType.INVALID_JSON, "Failed to process JSON", ex);
    } catch (IOException ex) {
      throw new FanartTvException(FanartTvException.FanartTvExceptionType.HTTP_ERROR, "Failed to connect to Fanart.TV server", ex);
    } 
  }
}
```

### Additional Classes

Here are the other classes (`FanartTvException`, `FTArtworkSort`, `FTArtworkType`, `FanartTvArtwork`, `WrapperMovie`, `WrapperMusic`, `WrapperSeries`, `FilteringLayout`, and `WebBrowser`):

**FanartTvException.java:**

```java
package com.omertron.fanarttvapi;

public class FanartTvException extends Exception {
  private static final long serialVersionUID = 1L;

  private FanartTvExceptionType type;

  public FanartTvException(FanartTvExceptionType type, String message, Throwable cause) {
    super(message, cause);
    this.type = type;
  }

  public FanartTvExceptionType getType() {
    return type;
  }

  public enum FanartTvExceptionType {
    INVALID_JSON,
    HTTP_ERROR,
    MAPPING_FAILED
  }
}
```

**FTArtworkSort.java:**

```java
package com.omertron.fanarttvapi.model;

public enum FTArtworkSort {
  DEFAULT, LATEST, OLDEST;
}
```

**FTArtworkType.java:**

```java
package com.omertron.fanarttvapi.model;

public enum FTArtworkType {
  ALL, BACKDROP, POSTER, FANART, BANNER, LOGO, THUMB;
}
```

**FanartTvArtwork.java:**

```java
package com.omertron.fanarttvapi.model;

import java.util.Date;

public class FanartTvArtwork {
  private String url;
  private String lang;
  private int likes;
  private Date added;
  private FTArtworkType type;

  // Getters and setters

  public String getUrl() {
    return url;
  }

  public void setUrl(String url) {
    this.url = url;
  }

  public String getLang() {
    return lang;
  }

  public void setLang(String lang) {
    this.lang = lang;
  }

  public int getLikes() {
    return likes;
  }

  public void setLikes(int likes) {
    this.likes = likes;
  }

  public Date getAdded() {
    return added;
  }

  public void setAdded(Date added) {
    this.added = added;
  }

  public FTArtworkType getType() {
    return type;
  }

  public void setType(FTArtworkType type) {
    this.type = type;
  }
}
```

**WrapperMovie.java:**

```java
package com.omertron.fanarttvapi.model;

import java.util.Map;
import java.util.List;

public class WrapperMovie {
  private Map<FTArtworkType, List<FanartTvArtwork>> artwork;

  public Map<FTArtworkType, List<FanartTvArtwork>> getArtwork() {
    return artwork;
  }

  public void setArtwork(Map<FTArtworkType, List<FanartTvArtwork>> artwork) {
    this.artwork = artwork;
  }
}
```

**WrapperMusic.java:**

```java
package com.omertron.fanarttvapi.model;

import java.util.Map;
import java.util.List;

public class WrapperMusic {
  private Map<FTArtworkType, List<FanartTvArtwork>> artwork;

  public Map<FTArtworkType, List<FanartTvArtwork>> getArtwork() {
    return artwork;
  }

  public void setArtwork(Map<FTArtworkType, List<FanartTvArtwork>> artwork) {
    this.artwork = artwork;
  }
}
```

**WrapperSeries.java:**

```java
package com.omertron.fanarttvapi.model;

import java.util.Map;
import java.util
